Elegant and Powerful Static Site Generator

Elegant and Powerful Static Site Generator

.images-inline img { display: inline; margin: 4px 2px;}

Latest Version on Packagist
Total Downloads on Packagist
Test Coverage
Scrutinizer Code Quality
Psalm Type Coverage
License MIT
{.images-inline .not-prose}

About HydePHP

HydePHP is a Static Site Generator focused on writing content, not markup. With Hyde, it is easy to create static
websites, blogs, and documentation pages using Markdown and (optionally) Laravel's Blade.

Operated entirely through the command-line, HydePHP provides developers with a fast and efficient way to create high-quality websites with ease.
Unlike traditional web development frameworks, sites compiled with HydePHP don't require any server to run,
making it an ideal choice for building lightweight and fast-loading websites.

Compared with other static site builders, Hyde is blazingly fast and seriously simple to get started with, yet it has the
full power of Laravel waiting for you when you need it, as Hyde is powered by Laravel Zero, a stripped-down version of
the robust and popular Laravel Framework, optimized for console applications.

Hyde makes creating websites easy and fun by taking care of the boring stuff, like routing, writing boilerplate, and
endless configuration. Instead, when you create a new Hyde project, everything you need to get started is already there
-- including precompiled TailwindCSS, well-crafted Blade templates, and easy-to-use asset management.

Hyde was inspired by JekyllRB and is designed for developers who are comfortable writing posts in Markdown, and it requires
virtually no configuration out of the box as it favours convention over configuration and is preconfigured with sensible defaults.

Installation

HydePHP is a command-line interface (CLI) application that is installed on a per-project basis.

To use HydePHP, your system must have PHP version 8.1 or later installed, along with Composer, and access to a terminal.

The recommended method of installation is using Composer.

composer create-project hyde/hyde

Once installed, you can access the HydeCLI from the project root using the hyde command.

php hyde info

Usage

Creating static websites with HydePHP is incredibly easy. First you need some content. You can just drop Markdown files
in any of the source directories, or let Hyde scaffold the files for you using one of the many commands.

php hyde make:post "My First Post"
php hyde make:page "About Me"

Once you have some content, you can run the build command to compile the content into beautiful static HTML.

php hyde build

And that's it, your amazing website is ready to be shared with the world!

To learn more, head over to the quickstart page.

Advanced Features in HydePHP

Advanced Features in HydePHP

Preface

HydePHP is a simple, yet powerful, static site generator. It is designed to be easy to use and easy to extend.

This section of the documentation will cover some of the more advanced (but optional) features of the framework.

Prerequisites

To fully understand the features described in these chapters, it may be beneficial to first skim through the
Architecture Concepts chapters, or at the very least, the Core Concepts page.

You are also expected to have a basic understanding of PHP, and object-oriented programming principles.

Having some familiarity with Laravel will also be beneficial, as HydePHP is built on top of the Laravel framework.

Table of Contents

[Blade]: @foreach(glob(DocumentationPage::path('advanced-features/*.md')) as $file)   {{ Hyde::makeTitle(basename($file, '.md')) }}   @endforeach

Custom Build Tasks

Custom Build Tasks

Introduction

The Build Task API offers a simple way to hook into the build process.
The build tasks are very powerful and allow for limitless customizability.

The built-in Hyde features like sitemap generation and RSS feeds are created using tasks like these.
Maybe you want to create your own, to for example upload the site to FTP or copy the files to a public directory?
You can also overload the built-in tasks to customize them to your needs.

Good to know before you start

Types of tasks

There are two types, PreBuildTasks and PostBuildTasks. As the names suggest, PreBuildTasks are executed before the site is built, and PostBuildTasks are executed after the site is built.

To choose which type of task you want to create, you extend either the PreBuildTask or PostBuildTask class.
Both of these have the exact same helpers and API available, so the only difference between them is when they are executed. The classes are otherwise identical.

About these examples

For most of these examples we will focus on the PostBuildTasks as they are the most common.

For all these examples we assume you put the file in the App/Actions directory, but you can put them anywhere.

Interacting with output

In a way, build tasks are like micro-commands, as they can interact directly with the build commands I/O. Please take a look at the Laravel Console Documentation for the full list of available methods.

In addition, there are some extra helpers available in the base BuildTask class that allow you to fluently format output to the console, which you will see in the examples below.

Creating build tasks

Minimal example

Here is a minimal example to give you an idea of what we are working with.

class SimpleBuildTask extends PostBuildTask
{
    public function handle(): void
    {
        //
    }
}

As you can see, at their core, build tasks are simple classes containing a handle() method,
which as I'm sure you have guessed, is the method that is executed when the task is run by the build command.

If you want the task to run before the build, you would extend the PreBuildTask class instead.

Automatic output

When running the build command, you will see the following output added after the build is complete.

 Generic build task... Done in 0.26ms

As you can see, some extra output including execution time tracking is added for us. We can of course customize all of this if we want, as you will learn a bit further down.

Full example

Here is a full example, with all the namespaces included, as well as the most common fluent output helpers.

info('Hello World!');
    }

    public function printFinishMessage(): void
    {
        $this->line('Goodbye World!');
    }
}

You can see a full API reference further below. But in short, the $message property is the message that runs before the task is executed, and the printFinishMessage() method is the message that runs after the task is executed.

Running this task will produce the following output:

$ php hyde build
  Say hello... Hello World!
  Goodbye World!

As you can see, there is no execution time tracking here, since we overrode the printFinishMessage() method that normally prints this. You can of course call the withExecutionTime() method to add this back in. See more in the API reference below.

Registering the tasks

There are a few ways to register these tasks so Hyde can find them.

They are shown here in order of presumed convenience, but you are free to choose whichever you prefer. The latter options are more suited for extension developers.

Autodiscovery registration

The easiest way to register build tasks, is to not do it. Just let Hyde do it for you!

Any classes that end in BuildTask.php that are stored in app/Actions  will be autoloaded and registered to run automatically.

For example: app/Actions/ExampleBuildTask.php.

Config file registration

If you want, you can also register build tasks of any namespace in the convenient build_tasks array which is in the main configuration file, config/hyde.php.

// filepath config/hyde.php
'build_tasks' => [
    \App\Actions\SimpleTask::class,
    \MyPackage\Tasks\MyBuildTask::class,
],

Programmatic registration

info This option assumes you are familiar with Laravel's service container and service providers.

If you are developing an extension, you can either instruct users register your tasks with the config option above,
or you can register the extensions programmatically, I recommend you do this in the boot method of a service provider.

The build tasks are registered in an internal array of the BuildService class, which is bound as a singleton in the underlying Laravel service container.
To actually register your task, provide the fully qualified class name of the task to the BuildTaskService::registerTask() method.

Here is an example of how to do this using in a service provider. Though you could technically do it anywhere using the app() helper, just as long as it's done early enough in the application lifecycle, so it's registered before the build command is executed.

class MyServiceProvider extends ServiceProvider
{
    public function boot(): void
    {
        $this->app->make(\Hyde\Framework\Services\BuildTaskService::class)
            ->registerTask(\MyPackage\Tasks\MyBuildTask::class);
    }
}

HydePage API Reference

# HydePage API Reference

warning This article covers advanced information, and you are expected to already be familiar with Page Models and OOP

## Abstract

This page contains the full API references for the built-in HydePage classes. Most users will not need to know about
the inner workings of classes, but if you're interested in extending HydePHP, or just curious, this page is for you.
It is especially useful if you're looking to implement your own page classes, or if you are creating advanced Blade templates.

### About the reference

This document is heavily based around the actual source code, as I believe the best way to understand the code is to read it.
However, large parts of the code are simplified for brevity and illustration. The code is not meant to be copy-pasted, but
rather used as a reference so that you know what to look for in the actual source code, if you want to dig deeper.

#### Inheritance

Since all HydePages extend the base HydePage class, those shared methods are only listed once,
under the HydePage class documentation which is conveniently located just below this section.

### Table of Contents

Class                                   Description

HydePage                   The base class for all Hyde pages.
BaseMarkdownPage   The base class for all Markdown pages.
InMemoryPage           Extendable class for in-memory pages.
BladePage              Class for Blade pages.
MarkdownPage           Class for Markdown pages.
MarkdownPost           Class for Markdown posts.
DocumentationPage Class for documentation pages.
HtmlPage                   Class for HTML pages.

## HydePage

The base class for all Hyde pages, all other page classes extend this class.

Unlike other frameworks, in general you don't instantiate pages yourself in Hyde, instead, the page models acts as
blueprints defining information for Hyde to know how to parse a file, and what data around it should be generated.

To create a parsed file instance, you'd typically just create a source file, and you can then access the parsed file
from the HydeKernel's page index.

In Blade views, you can always access the current page instance being rendered using the $page variable.

### Quick Reference

Class Name Namespace             Source Code                                                                                        API Docs

HydePage Hyde\Pages\Concerns Open in GitHub Live API Docs

### Base Structure

/**
 * The base class for all Hyde pages. Here simplified for the sake of brevity.
 */
abstract class HydePage
{
    /**
     * The directory in which source files are stored. Relative to the project root.
     */
    public static string $sourceDirectory;

    /**
     * The output subdirectory to store compiled HTML. Relative to the _site output directory.
     */
    public static string $outputDirectory;

    /**
     * The file extension of the source files.
     */
    public static string $fileExtension;

    /**
     * The default template to use for rendering the page.
     */
    public static string $template;

    /**
     * The page instance identifier.
     */
    public readonly string $identifier;

    /**
     * The page instance route key.
     */
    public readonly string $routeKey;

    /**
     * The parsed front matter.
     */
    public FrontMatter $matter;

    /**
     * The generated page metadata.
     */
    public PageMetadataBag $metadata;

    /**
     * The generated page navigation data.
     */
    public NavigationData $navigation;
}

### Methods

warning Heads up! The following methods are defined in the HydePage class, and are thus available to all page classes. Since the HydePage class is abstract, you cannot instantiate it directly, and many of the static methods are also only callable from the child classes.

[Blade]: {{ Hyde\Markdown\Models\Markdown::fromFile(DocumentationPage::sourcePath('_data/partials/hyde-pages-api/hyde-page-methods'))->toHtml($page::class) }}

[Blade]: {{ Hyde\Markdown\Models\Markdown::fromFile(DocumentationPage::sourcePath('_data/partials/hyde-pages-api/interacts-with-front-matter-methods'))->toHtml($page::class) }}

## BaseMarkdownPage

The base class for all Markdown-based page models, with additional helpers tailored for Markdown pages.

### Quick Reference

Class Name         Namespace             Source Code                                                                                                API Docs

BaseMarkdownPage Hyde\Pages\Concerns Open in GitHub Live API Docs

### Base Structure

/**
 * The base class for all Markdown-based page models. Here simplified for the sake of brevity.
 */
abstract class BaseMarkdownPage extends HydePage
{
    public Markdown $markdown;

    public static string $fileExtension = '.md';
}

### Methods

[Blade]: {{ Hyde\Markdown\Models\Markdown::fromFile(DocumentationPage::sourcePath('_data/partials/hyde-pages-api/base-markdown-page-methods'))->toHtml($page::class) }}

## InMemoryPage

Before we take a look at the common page classes, you'll usually use, let's first take a look at one that's quite interesting.

This class is especially useful for one-off custom pages. But if your usage grows, or if you want to utilize Hyde
autodiscovery, you may benefit from creating a custom page class instead, as that will give you full control.

You can learn more about the InMemoryPage class in the InMemoryPage documentation.

### Quick Reference

Class Name     Namespace    Source Code                                                                                   API Docs

InMemoryPage Hyde\Pages Open in GitHub Live API Docs

### Base Structure

As the class is not discoverable, the static path properties are not initialized. Instead, you solely rely on the contents/view properties.

You can also define macros which allow you to both add methods to the instance, but also to overload some built-in ones like the compile method.

/**
 * The InMemoryPage class, here simplified for the sake of brevity.
 */
class InMemoryPage extends HydePage
{
    public static string $sourceDirectory;
    public static string $outputDirectory;
    public static string $fileExtension;

    protected string $contents;
    protected string $view;

    /* @var array /
    protected array $macros = [];
}

### Methods

[Blade]: {{ Hyde\Markdown\Models\Markdown::fromFile(DocumentationPage::sourcePath('_data/partials/hyde-pages-api/in-memory-page-methods'))->toHtml($page::class) }}

## BladePage

Page class for Blade pages.

Blade pages are stored in the _pages directory and using the .blade.php extension.
They will be compiled using the Laravel Blade engine the _site/ directory.

### Quick Reference

Class Name  Namespace    Source Code                                                                                API Docs

BladePage Hyde\Pages Open in GitHub Live API Docs

### Base Structure

class BladePage extends HydePage
{
    public static string $sourceDirectory = '_pages';
    public static string $outputDirectory = '';
    public static string $fileExtension = '.blade.php';
}

### Methods

[Blade]: {{ Hyde\Markdown\Models\Markdown::fromFile(DocumentationPage::sourcePath('_data/partials/hyde-pages-api/blade-page-methods'))->toHtml($page::class) }}

## MarkdownPage

Page class for Markdown pages.

Markdown pages are stored in the _pages directory and using the .md extension.
The Markdown will be compiled to HTML using a minimalistic layout to the _site/ directory.

### Quick Reference

Class Name     Namespace    Source Code                                                                                   API Docs

MarkdownPage Hyde\Pages Open in GitHub Live API Docs

### Base Structure

class MarkdownPage extends BaseMarkdownPage
{
    public static string $sourceDirectory = '_pages';
    public static string $outputDirectory = '';
    public static string $template = 'hyde::layouts/page';
}

### Methods

This class does not define any additional methods.

## MarkdownPost

Page class for Markdown blog posts.

Markdown posts are stored in the _posts directory and using the .md extension.
The Markdown will be compiled to HTML using the blog post layout to the _site/posts/ directory.

### Quick Reference

Class Name     Namespace    Source Code                                                                                   API Docs

MarkdownPost Hyde\Pages Open in GitHub Live API Docs

### Base Structure

class MarkdownPost extends BaseMarkdownPage
{
    public static string $sourceDirectory = '_posts';
    public static string $outputDirectory = 'posts';
    public static string $template = 'hyde::layouts/post';

    public ?string $description;
    public ?string $category;
    public ?DateString $date;
    public ?PostAuthor $author;
    public ?FeaturedImage $image;
}

### Methods

[Blade]: {{ Hyde\Markdown\Models\Markdown::fromFile(DocumentationPage::sourcePath('_data/partials/hyde-pages-api/markdown-post-methods'))->toHtml($page::class) }}

## DocumentationPage

Page class for documentation pages.

Documentation pages are stored in the _docs directory and using the .md extension.
The Markdown will be compiled to HTML using the documentation page layout to the _site/docs/ directory.

### Quick Reference

Class Name          Namespace    Source Code                                                                                        API Docs

DocumentationPage Hyde\Pages Open in GitHub Live API Docs

### Base Structure

class DocumentationPage extends BaseMarkdownPage
{
    public static string $sourceDirectory = '_docs';
    public static string $outputDirectory = 'docs';
    public static string $template = 'hyde::layouts/docs';
}

### Methods

[Blade]: {{ Hyde\Markdown\Models\Markdown::fromFile(DocumentationPage::sourcePath('_data/partials/hyde-pages-api/documentation-page-methods'))->toHtml($page::class) }}

## HtmlPage

Page class for HTML pages.

Html pages are stored in the _pages directory and using the .html extension.
These pages will be copied exactly as they are to the _site/ directory.

### Quick Reference

Class Name Namespace    Source Code                                                                               API Docs

HtmlPage Hyde\Pages Open in GitHub Live API Docs

### Base Structure

class HtmlPage extends HydePage
{
    public static string $sourceDirectory = '_pages';
    public static string $outputDirectory = '';
    public static string $fileExtension = '.html';
}

### Methods

[Blade]: {{ Hyde\Markdown\Models\Markdown::fromFile(DocumentationPage::sourcePath('_data/partials/hyde-pages-api/html-page-methods'))->toHtml($page::class) }}

InMemoryPages

InMemoryPages

Introduction

This class is a special page class that is not backed by a file on disk, but rather generated at runtime. While it will
probably not be useful for the majority of users, it's a great class to know about if you are a package developer,
but feel free to skip this section if you're not interested in this.

When to use

This class is especially useful for one-off custom pages. But if your usage grows, or if you want to utilize Hyde
autodiscovery, you may benefit from creating a custom page class instead, as that will give you full control.

About discovery

Since the InMemoryPages are not present in the filesystem, they cannot be found by the auto-discovery process,
thus it's up to the developer to manually register them. If you are developing for your own project, you can do this in
the boot method of a service provider, such as the AppServiceProvider which is already present in your app/ directory.

If you are developing a package, you may instead want to register the page in your package extension class, within the
page collection callback. In either case, if you want your page to be able to be fully processed by Hyde, you need to
make sure you register it before the full application is booted so that routes can be generated.

To see how to register the page, see the examples below, first we must look at how to actually create the page.

Creating the page

To create an InMemoryPage, you need to instantiate it, and pass it the required parameters.

A page would not be useful without any content to render. The class offers two content options through the constructor.

You can either pass a string to the $contents parameter, Hyde will then save that literally as the page's contents.

$page = new InMemoryPage(contents: 'Hello World!');

Alternatively, you can pass a Blade view name to the $view parameter, and Hyde will use that view to render the page
contents with the supplied front matter during the static site build process.

warning Note that $contents take precedence over $view, so if you pass both, only $contents will be used.

You can also register a macro with the name compile to overload the default compile method.

API Reference

To see all the methods available, please see the InMemoryPage API reference.

Advanced Architecture Concepts

Advanced Architecture Concepts

Introduction

These chapters are written for power users and package contributors. If you're just looking to get a site up and running,
you can safely skip this section. The documentation here will cover advanced topics under the presumption that
the reader has a basic to intermediate understanding of programming, as well as PHP, object-oriented design,
and to some extent Laravel, as the articles are heavily driven by code examples.

You are of course free to skip this entire section, as you don't need to know these things to use Hyde.
However, if you want to know the "magic" behind Hyde, or if you want to take advantage of these powerful tools,
then by all means, please read on! This is also a great place to start if you want to contribute to the source code.

info For a high-level overview of these concepts, see the Basic Architecture Concepts page.

Behind the magic

Want to learn more about a particular feature? Click on the links below to visit the article.

[//]: # (This would be better suited for a component, but it's a fun experiment for now)
[Blade]: @foreach(glob(DocumentationPage::path('architecture-concepts/*.md')) as $file)   {{ Hyde::makeTitle(basename($file, '.md')) }}   @endforeach

Autodiscovery

Autodiscovery

Introduction

HydePHP aims to reduce the amount of configuration you need to do to get a site up and running.
To that end, Hyde uses a process called autodiscovery to automatically find and register your pages.

This article will go into detail about how autodiscovery works as well as the lifecycle of the HydeKernel.

The short version

Hyde will use the information in the page model classes to scan the source directories for matching files which are
parsed using instructions from the model's class, resulting in data used to construct objects that get stored in the HydeKernel.

Prerequisites

Before reading this article, you should be familiar with the following concepts:
-  Page Models
-  The HydeKernel

Booting pipeline

The autodiscovery is run when the HydeKernel boots. It does so in three distinct steps, which run in sequence as each
step depends on the previous one. Each discovery step runs in a FoundationCollection which both runs the actual
discovery process and stores the discovered data in memory.

The steps are as follows:

1. Step one: The file collection discovers all the source files and stores them in memory
2. Step two: The page collection parses all the source files into page model objects
3. Step three: The route collection generates route objects for all the pages

Interacting with the collections

Usually, you will interact with the collection data through intermediaries.
* For example, if you call MarkdownPost::get('my-post'), Hyde will retrieve that page from the page collection.
* If you call Routes::get('index'), Hyde will retrieve that route from the route collection.

The HydeKernel

If you have not yet read the HydeKernel Documentation, here's a quick recap:

The HydeKernel encapsulates a HydePHP project, providing helpful methods for interacting with it.
It is also responsible for booting the application, which includes the autodiscovery process.

The kernel is created very early on in the application lifecycle, in the bootstrap.php file, where it is also bound
as a singleton into the application service container.

At this point you might be wondering why we're talking about the kernel when this article is about autodiscovery.
Well, as you'll see in just a moment, the kernel is responsible for initiating the autodiscovery process.
The kernel is also where the discovered data is stored in memory, so it's important to understand how it works.

The kernel lifecycle

Now that we know the role of the HydeKernel, let's take a look at its lifecycle. The kernel is "lazy-booted", meaning
that the all the heavy lifting only happens when you actually need it. Once booted, the kernel data will stay in memory
until the console application is terminated.

The kernel data is primarily stored in three collections that get generated during the kernel's boot process.
Let's take a look at a simplified version of the kernel's boot method to see how this works.

public function boot(): void
{
    $this->files = FileCollection::boot($this);
    $this->pages = PageCollection::boot($this);
    $this->routes = RouteCollection::boot($this);

    // Scroll down to see what this is used for
    $this->booted = true;
}

Here you'll see that we boot the three collections. This is where all the autodiscovery magic happens!

Deep dive into lazy-booting

If you're curious about how the kernel is lazy-booted, here's how it works!
Feel free to skip this section if this doesn't interest you.

// This will boot the kernel if it hasn't been booted yet
public function pages(): PageCollection
{
    $this->needsToBeBooted();

    return $this->pages;
}

// This is the method that triggers the boot process
protected function needsToBeBooted(): void
{
    if (! $this->booted) {
        $this->boot();
    }
}

Yeah, it's really unglamorous I know. But it works! Having it like this will ensure that any time you call Hyde::pages(),
that underlying collection will always have been booted and be ready to use.

Automatic Routing

Automatic Routing

info This covers an intermediate topic which is not required for basic usage, but is useful if you want to use the framework to design custom Blade templates.

High-level overview

If you've ever worked in an MVC framework, you are probably familiar with the concept of routing.
And you are probably also familiar with how boring and tedious it can be. Thankfully, Hyde takes the pain out of routing
through the Hyde Autodiscovery process.

Internally, when booting the HydeCLI application, Hyde will automatically discover all the content files in the source
directories, and create a route index for all of them. This index works as a two-way link between source files and compiled files.

Don't worry if this sounds complex, as the key takeaway is that the index is created and maintained automatically.
Nevertheless, the routing system provides several helpers that you can optionally use in your Blade views to
automatically resolve relative links and other useful features.

You can see all the routes and their corresponding source files by running the hyde route:list command.

php hyde route:list

Accessing routes

Each route in your site is represented by a Route object. It's very easy to get a Route object instance from the Router's index.
There are a few ways to do this, but most commonly you'll use the Routes facade's get() method where you provide a route key,
and it will return the Route object. The route key is generally ``. Here are some examples:

// Source file: _pages/index.md/index.blade.php
// Compiled file: _site/index.html
Routes::get('index')

// Source file: _posts/my-post.md
// Compiled file: _site/posts/my-post.html
Routes::get('posts/my-post')

// Source file: _docs/readme.md
// Compiled file: _site/docs/readme.html
Routes::get('docs/readme')

Using the x-link component

When designing Blade layouts it can be useful to use the x-link component to automatically resolve relative links.

You can of course, use it just like a normal anchor tag like so:

Home

But where it really shines is when you supply a route. This will then resolve the proper relative link, and format it to use pretty URLs if your site is configured to use them.

Home

You can of course, also supply extra attributes like classes:

Home

Dynamic Data Discovery

Dynamic Data Discovery

[//]: # (Adds a pseudo-subtitle)
AKA: Front Matter & Filling in the Gaps

Introduction

Hyde wants to allow developers to write less, and do more. This is also a major difference between HydePHP and JekyllRB.
Jekyll will only do what you tell it to do. Hyde, on the other hand, will try to do what you want it to do.

As with all other chapters in this category, you don't need to know about this to use Hyde -- that's the whole point!
However, if you're anything like me, you'll likely find this interesting to read about, even if you don't really need to know it.

Hyde makes great use of front matter in both Markdown and Blade files (it's true!). However, it can quickly get tedious
and quite frankly plain boring to have to write a bunch of front matter all the time. As Hyde wants you to focus on
your content, and not your markup, front matter is optional and Hyde will try to fill in the gaps for you.

If you're not happy with Hyde's generated data you can always override it by adding front matter to your files.

How it Works

Now, to the fun part: getting into the nitty-gritty details of how Hyde does this!

To make things simple the dynamic data is created in a special stage where the page object is being created.
If you have not yet read the page models chapter you might want to do so now.
You might also want to read about the autodiscovery lifecycle for some context as to when this happens.

The factory pipeline, in short

After basic information about the page has been gathered, such as the source file information and the front matter,
the page model is run through a series of factories. These are just classes that work around the limited data
that is available at this point, and will assign the rich data needed to make your Hyde page awesome.

There are a few factory classes. The one we will be looking at here is the HydePageDataFactory class, which is
responsible for data applicable to all page models. Complex structures and data only relevant to some page types
have their own factories, making the code more modular and maintainable.

In-depth overview of a page factory

Let's take a look at how Hyde will discover the title of a page as an example. Since this is something used by all pages,
this discovery is done in the HydePageDataFactory class.

Factory data input

The factory gets one input, a CoreDataObject class. Think of this like a DTO (Data Transfer Object) that holds
immutable data known from the start of the page construction process. It also has all the information needed
to identify the page and its source file. Here's a simplified version of the class:

class CoreDataObject
{
    public readonly FrontMatter $matter;
    public readonly Markdown|false $markdown;

    public readonly string $pageClass;
    public readonly string $identifier;
    public readonly string $sourcePath;
    public readonly string $outputPath;
    public readonly string $routeKey;
}

Processing the known data

Now that we have the input we pass it to the factory, where a simple algorithm is used to find the best title for the page.

private function findTitleForPage(): string
{
    return $this->matter('title')
        ?? $this->findTitleFromMarkdownHeadings()
        ?? Hyde::makeTitle(basename($this->identifier));
}

As you can see, we are using the null coalescing operator (??) to return the first non-null value. We always want the
user to be able to set any data explicitly, so we first check the front matter in all factory methods.

If no title is set in the matter the method will return null, and Hyde will try the next step which is to search the headings.
If that fails, the last step will generate a title from the file name. This ensures that no matter what, we always have a title.

Injecting the data into the page

Once the data has been discovered, it is injected into the page object. This is rather unglamorous but is mentioned
here for completeness. It's pretty simple. The factory will always return an array of the computed data, where the keys
always match the property names on the page object, so we just need to loop over the array and set the properties.

foreach ($data->toArray() as $key => $value) {
    $this->{$key} = $value;
}

And that's pretty much it! Hyde will do this for all the data it can discover, all so that you can focus on your content.

The Extensions API

The Extensions API

Introduction

The Extensions API a powerful interface designed for package developers who want to extend the functionality of HydePHP.

Using the API, you can hook directly into the HydePHP Kernel and extend sites with custom page types and new features.

This documentation page functions heavily through examples, so it's recommended that the sections are read in order.

Prerequisites

Before creating your extension, it will certainly be helpful if you first become familiar with
the basic internal architecture of HydePHP, as well as how the auto-discovery system works,
so you can understand how your code works with the internals.

- Core concepts overview
- Architecture concepts
- Autodiscovery

The why and how of the Extensions API

HydePHP being a static site generator, the Extensions API is centered around Page Models,
which you are hopefully already familiar with, otherwise you should read up on them first.

What the Extensions API does is to allow you to create custom page types, and tell HydePHP how to discover them.
This may sound like a small thing, but it's actually incredibly powerful as the page models are the foundation
of HydePHP's functionality. They tell the system how to discover pages, how to render them,
and how they interact with the site.

Any other functionality you want to add to HydePHP, such as new commands or configuration options,
can be added the same way as you would in Laravel, and are thus not part of our API.
See the Laravel package development guide for more.

Creating your Extension class

The entry-point for your extension is your Extensions class. Within this, you can register the custom page classes.
If needed, you can also register discovery handlers which can run custom logic at various parts of the boot process.

In this article we will create an extension that registers a new type of page, a JsonPageExtension.

The first step is to create a class that extends the HydeExtension class:

use Hyde\Foundation\Concerns\HydeExtension;

class JsonPageExtension extends HydeExtension {
    //
}

In here, we will register our extension class name in the getPageClasses method:

class JsonPageExtension extends HydeExtension {
    public static function getPageClasses(): array {
        return [
            JsonPage::class,
        ];
    }
}

Hyde will then use the information from the JsonPage class to automatically discover the pages when booting the Kernel.
For example, if you specify the file extension and source directory, that is all Hyde needs to know to discover the pages.

If our pages need more complex discovery logic, we can create custom handlers. so let's take a quick look at that next.

Discovery handlers

The discovery handlers lets you run code at various points of the booting process. This is usually only needed if your
page models cannot provide the information required for Hyde run the standard auto-discovery, and thus need custom logic.

Usually in these cases, you would only need to add files to the Kernel FileCollection,
though the HydeExtension class offers following three discovery handlers, in case you need them:

/* Runs during file discovery /
public function discoverFiles(FileCollection $collection): void;

/* Runs during page discovery /
public function discoverPages(PageCollection $collection): void;

/* Runs during route discovery /
public function discoverRoutes(RouteCollection $collection): void;

Any of these can be implemented in your extension class, and they will be called during the discovery. As you can see,
the instance of the discovery collection is injected into the method for you to interact with.

Discovery handler example

Let's go crazy and implement a discovery handler to collect JsonPage files from an external API! We will do this
by implementing the discoverPages method in our extension class, and from there inject pages retrieved from our API.

class JsonPageExtension extends HydeExtension {
    public function discoverPages(PageCollection $collection): void {
        $pages = Http::get('https://example.com/my-api')->collect();

        $pages->each(function (array $page) use ($collection): void {
            $collection->addPage(JsonPage::fromArray($page));
        });
    }
}

Since the discovery steps are handled sequentially, the added pages will automatically be discovered as routes without
us having to implement that handler method. As we inject the page objects directly, we bypass the need of the FileCollection.

Registering your extension

Now that we have our extension class, we need to register it with HydePHP.

It's important that your class is registered before the HydeKernel boots. Therefore, an excellent place for this is the
register method of your extensions service provider,  where you call the registerExtension method of the HydeKernel
singleton instance, which you can access via the Hyde\Hyde facade, or via the service container.

use Hyde\Hyde;
use Hyde\Foundation\HydeKernel;
use Illuminate\Support\ServiceProvider;

class JsonPageExtensionServiceProvider extends ServiceProvider {
    public function register(): void {
        // Via the service container:
        $this->app->make(HydeKernel::class)->registerExtension(JsonPageExtension::class);

        // Or via the facade:
        Hyde::registerExtension(JsonPageExtension::class);
    }
}

Packaging your extension

To make your extension available to other HydePHP users, you can make it into a Composer package,
and publish it to Packagist for others to install.

If you register your service provider in your package's composer.json file, your extension automatically be enabled when
the package is installed in a HydePHP project!

{
  "extra": {
    "laravel": {
      "providers": [
        "My\\Namespace\\JsonPageExtensionServiceProvider"
      ]
    }
  }
}

Telling the world about your extension

Next up, why not send us a Tweet at @HydeFramework and tell us about your extension,
so we can feature it?

Page models

The Hyde Page Models

Introduction

The Hyde page models are an integral part of how HydePHP creates your static site. Each page in your site is represented
by a page model. These are simply PHP classes that in addition to holding both the source content and computed data
for your pages, also house instructions to Hyde on how to parse, process, and render the pages to static HTML.

In this article, you'll get a high-level overview of the page models, and some code examples to give you a look inside.

The short version

Page models are classes that have two primary concerns:

1. They act as blueprints containing static instructions for how to parse, process, and, render pages.
2. Each class instance also holds the page source contents, as well as the computed data.

Other key points:

- HydePHP, at the time of writing, comes with five different page classes, one for each supported type.
- You don't construct page models yourself. HydePHP does it for you by the autodiscovery process.
- Page models are just PHP classes. You can extend them, and you can implement your own.

The Page Model

To give you an idea of what a page model class looks like, here's a simplified version of the base MarkdownPost class,
Don't worry if you don't understand everything yet, we'll talk more about these parts later.

class MarkdownPost extends BaseMarkdownPage
{
    public static string $sourceDirectory = '_posts';
    public static string $outputDirectory = 'posts';
    public static string $fileExtension = '.md';
    public static string $template = 'post';

    public string $identifier;
    public string $routeKey;
    public string $title;

    public FrontMatter $matter;
    public Markdown $markdown;
}

_Note that since Hyde pages are modular through class inheritance and traits, this example has been simplified and
edited to show all the relevant parts inlined into one class._

Page Models as Blueprints

All page models have some static properties (that is, they belong to the class, not the instance) that are used as
blueprints, defining information for Hyde to know how to parse a file, and what data around it should be generated.

Let's again take the simplified MarkdownPost class as an example, this time only showing the static properties:

class MarkdownPost extends BaseMarkdownPage
{
    public static string $sourceDirectory = '_posts';
    public static string $outputDirectory = 'posts';
    public static string $fileExtension = '.md';
    public static string $template = 'post';
}

What each property does

The properties should be self-explanatory, but here's a quick rundown to give some context on how they are used,
and how the paths relate to each other. So for the class above, Hyde will thanks to this blueprint, know to:
* Look for files in the _posts directory, with the .md extension
* Compile the page using the post Blade template
* Output the compiled page to the _site/posts directory

Page Models as Data Containers

As mentioned above, each page model instance also holds the page source contents, as well as the computed data.

Let's again take the simplified MarkdownPost class as an example, this time only showing the instance properties:

class MarkdownPost extends BaseMarkdownPage
{
    public string $identifier;
    public string $routeKey;
    public string $title;

    public FrontMatter $matter;
    public Markdown $markdown;
}

There are some more properties than shown here, for example, various metadata properties, but these are the most common
and important ones.

While the static data gives instructions to Hyde on how to process all pages of the type, the instance data tells Hyde
how to process a specific page. For example, the identifier property is used to uniquely identify the page, and
the routeKey property is used to generate the URL for the page.

The matter and markdown properties as I'm sure you can guess, hold the page's front matter and markdown content.
These can then also be processed by page factories to generate the computed data like the
title property.

The HydeKernel

The HydeKernel

Introduction

In the centre, or should I say core, of HydePHP is the HydeKernel. The kernel encapsulates a HydePHP project and
provides helpful methods for interacting with it. You can think of it as the heart of HydePHP, if you're a romantic.

The HydeKernel is so important that you have probably used it already. The main entry point for the HydePHP
API is the Hyde facade, which calls methods on the kernel.

use Hyde\Hyde;
use Hyde\Foundation\HydeKernel;

Hyde::version(); // calls $HydeKernel->version()

The kernel is created very early on in the application lifecycle, in the bootstrap.php file, where it is also bound
as a singleton into the application service container.

Accessing the kernel

The HydeKernel It is stored as a singleton in this class, and is bound into the
Laravel Application Service Container, and can be accessed in a few ways.

Commonly, you'll use the Hyde facade, but you can also use Dependency Injection
by type-hinting the HydeKernel::class, or use the hyde() function to get the Kernel.

The Kernel instance is constructed in bootstrap.php, and is available globally as $hyde.

Here are some examples of how you can call methods on the Kernel. All methods call the same method on the same instance, so it's just a matter of preference.

use Hyde\Hyde;
use Hyde\Foundation\HydeKernel;

Hyde::version();
Hyde::kernel()->version();
HydeKernel::getInstance()->version();
app(HydeKernel::class)->version();
hyde()->version();

The kernel lifecycle

Whenever we talk about the kernel being "booted" we are talking about the kernel's role in the autodiscovery process.

You can read all about it in the Autodiscovery Documentation.

API Reference

Since the most common way to interact with the kernel is through the Hyde facade, we will use that for the examples.
But you could just as well chain the methods on the accessed kernel singleton instance if you wanted.

version()

No description provided.

// torchlight! {"lineNumbers": false}
Hyde::version(): string

__construct()

No description provided.

// torchlight! {"lineNumbers": false}
$hyde = new HydeKernel(string $basePath): void

features()

No description provided.

// torchlight! {"lineNumbers": false}
Hyde::features(): Hyde\Facades\Features

hasFeature()

No description provided.

// torchlight! {"lineNumbers": false}
Hyde::hasFeature(string $feature): bool

toArray()

Get the instance as an array.

// torchlight! {"lineNumbers": false}
Hyde::toArray(): array

files()

No description provided.

// torchlight! {"lineNumbers": false}
Hyde::files(): \Hyde\Foundation\Kernel\FileCollection

pages()

No description provided.

// torchlight! {"lineNumbers": false}
Hyde::pages(): \Hyde\Foundation\Kernel\PageCollection

routes()

No description provided.

// torchlight! {"lineNumbers": false}
Hyde::routes(): \Hyde\Foundation\Kernel\RouteCollection

makeTitle()

No description provided.

// torchlight! {"lineNumbers": false}
Hyde::makeTitle(string $value): string

normalizeNewlines()

No description provided.

// torchlight! {"lineNumbers": false}
Hyde::normalizeNewlines(string $string): string

stripNewlines()

No description provided.

// torchlight! {"lineNumbers": false}
Hyde::stripNewlines(string $string): string

trimSlashes()

No description provided.

// torchlight! {"lineNumbers": false}
Hyde::trimSlashes(string $string): string

markdown()

No description provided.

// torchlight! {"lineNumbers": false}
Hyde::markdown(string $text, bool $normalizeIndentation): Illuminate\Support\HtmlString

formatLink()

No description provided.

// torchlight! {"lineNumbers": false}
Hyde::formatLink(string $destination): string

relativeLink()

No description provided.

// torchlight! {"lineNumbers": false}
Hyde::relativeLink(string $destination): string

mediaLink()

No description provided.

// torchlight! {"lineNumbers": false}
Hyde::mediaLink(string $destination, bool $validate): string

asset()

No description provided.

// torchlight! {"lineNumbers": false}
Hyde::asset(string $name, bool $preferQualifiedUrl): string

url()

No description provided.

// torchlight! {"lineNumbers": false}
Hyde::url(string $path): string

hasSiteUrl()

No description provided.

// torchlight! {"lineNumbers": false}
Hyde::hasSiteUrl(): bool

filesystem()

No description provided.

// torchlight! {"lineNumbers": false}
Hyde::filesystem(): Hyde\Foundation\Kernel\Filesystem

path()

No description provided.

// torchlight! {"lineNumbers": false}
Hyde::path(string $path): string

vendorPath()

No description provided.

// torchlight! {"lineNumbers": false}
Hyde::vendorPath(string $path, string $package): string

mediaPath()

No description provided.

// torchlight! {"lineNumbers": false}
Hyde::mediaPath(string $path): string

sitePath()

No description provided.

// torchlight! {"lineNumbers": false}
Hyde::sitePath(string $path): string

siteMediaPath()

No description provided.

// torchlight! {"lineNumbers": false}
Hyde::siteMediaPath(string $path): string

pathToAbsolute()

No description provided.

// torchlight! {"lineNumbers": false}
Hyde::pathToAbsolute(array|string $path): array|string

pathToRelative()

No description provided.

// torchlight! {"lineNumbers": false}
Hyde::pathToRelative(string $path): string

getInstance()

No description provided.

// torchlight! {"lineNumbers": false}
Hyde::getInstance(): Hyde\Foundation\HydeKernel

setInstance()

No description provided.

// torchlight! {"lineNumbers": false}
Hyde::setInstance(Hyde\Foundation\HydeKernel $instance): void

getBasePath()

No description provided.

// torchlight! {"lineNumbers": false}
Hyde::getBasePath(): string

setBasePath()

No description provided.

// torchlight! {"lineNumbers": false}
Hyde::setBasePath(string $basePath): void

getSourceRoot()

No description provided.

// torchlight! {"lineNumbers": false}
Hyde::getSourceRoot(): string

setSourceRoot()

No description provided.

// torchlight! {"lineNumbers": false}
Hyde::setSourceRoot(string $sourceRoot): void

getOutputDirectory()

No description provided.

// torchlight! {"lineNumbers": false}
Hyde::getOutputDirectory(): string

setOutputDirectory()

No description provided.

// torchlight! {"lineNumbers": false}
Hyde::setOutputDirectory(string $outputDirectory): void

getMediaDirectory()

No description provided.

// torchlight! {"lineNumbers": false}
Hyde::getMediaDirectory(): string

setMediaDirectory()

No description provided.

// torchlight! {"lineNumbers": false}
Hyde::setMediaDirectory(string $mediaDirectory): void

getMediaOutputDirectory()

No description provided.

// torchlight! {"lineNumbers": false}
Hyde::getMediaOutputDirectory(): string

registerExtension()

Register a HydePHP extension within the HydeKernel.

Typically, you would call this method in the register method of a service provider. If your package uses the standard Laravel (Composer) package discovery feature, the extension will automatically be enabled when the package is installed.

// torchlight! {"lineNumbers": false}
Hyde::registerExtension(class-string&lt;\Hyde\Foundation\Concerns\HydeExtension&gt; $extension): void

getExtension()

Get the singleton instance of the specified extension.

// torchlight! {"lineNumbers": false}
Hyde::getExtension(class-string&lt;T&gt; $extension): T

hasExtension()

Determine if the specified extension is registered.

// torchlight! {"lineNumbers": false}
Hyde::hasExtension(class-string&lt;\Hyde\Foundation\Concerns\HydeExtension&gt; $extension): bool

getExtensions()

No description provided.

// torchlight! {"lineNumbers": false}
Hyde::getExtensions(): array

getRegisteredExtensions()

No description provided.

// torchlight! {"lineNumbers": false}
Hyde::getRegisteredExtensions(): array>

getRegisteredPageClasses()

No description provided.

// torchlight! {"lineNumbers": false}
Hyde::getRegisteredPageClasses(): array>

shareViewData()

Share data for the page being rendered.

// torchlight! {"lineNumbers": false}
Hyde::shareViewData(Hyde\Pages\Concerns\HydePage $page): void

currentRouteKey()

Get the route key for the page being rendered.

// torchlight! {"lineNumbers": false}
Hyde::currentRouteKey(): string

currentRoute()

Get the route for the page being rendered.

// torchlight! {"lineNumbers": false}
Hyde::currentRoute(): Hyde\Support\Models\Route

currentPage()

Get the page being rendered.

// torchlight! {"lineNumbers": false}
Hyde::currentPage(): Hyde\Pages\Concerns\HydePage

isBooted()

Determine if the Kernel has booted.

// torchlight! {"lineNumbers": false}
Hyde::isBooted(): bool

boot()

Boot the Hyde Kernel and run the Auto-Discovery Process.

// torchlight! {"lineNumbers": false}
Hyde::boot(): void

booting()

Register a new boot listener.

Your callback will be called before the kernel is booted. You can use this to register your own routes, pages, etc. The kernel instance will be passed to your callback.

// torchlight! {"lineNumbers": false}
/* @param callable(\Hyde\Foundation\HydeKernel): void $callback /
Hyde::booting(callable(\Hyde\Foundation\HydeKernel): void): void

booted()

Register a new &quot;booted&quot; listener.

Your callback will be called after the kernel is booted. You can use this to run any logic after discovery has completed. The kernel instance will be passed to your callback.

// torchlight! {"lineNumbers": false}
/* @param callable(\Hyde\Foundation\HydeKernel): void $callback /
Hyde::booted(callable(\Hyde\Foundation\HydeKernel): void): void

Creating Blog Posts

Creating Blog Posts

Introduction to Hyde Posts

Making blog posts with Hyde is easy. At the most basic level, all you need is to add a Markdown file to your _posts folder.

To use the full power of the Hyde post module however, you'll want to add YAML Front Matter to your posts.

You can interactively scaffold posts with automatic front matter using the HydeCLI:

php hyde make:post
Learn more about scaffolding posts, and other files, in the console commands documentation.

Short Video Tutorial

Best Practices and Hyde Expectations

Since Hyde does a lot of things automatically, there are some things you may need
to keep in mind when creating blog posts so that you don't get unexpected results.

Filenames

- Markdown post files are stored in the _posts directory
- The filename is used as the filename for the compiled HTML
- Filenames should use kebab-case-name followed by the extension .md
- Files prefixed with _underscores are ignored by Hyde
- Your post will be stored in _site/posts/.html

Example:

✔ posts/hello-world.md # Valid and will be compiled to site/posts/hello-world.html

Front Matter

Front matter is optional, but highly recommended for blog posts as the front matter is used to construct dynamic HTML
markup for the post as well as meta tags and post feeds.

You are encouraged to look at the compiled HTML to learn
and understand how your front matter is used. You can read more about the Front Matter format in the Front Matter documentation.

Blog Post Example

Before digging in deeper on all the supported options, let's take a look at what a basic post with front matter looks like.

// filepath _posts/my-new-post.md
title: My New Post
description: A short description used in previews and SEO
category: blog
author: Mr. Hyde
date: 2022-05-09 18:38
Write your Markdown here

Lorem ipsum dolor sit amet, consectetur adipisicing elit.
Autem aliquid alias explicabo consequatur similique,
animi distinctio earum ducimus minus, magnam.

Supported Front Matter properties

Post Front Matter Schema

Here is a quick reference of the supported front matter properties.
Keep on reading to see further explanations, details, and examples.

KEY NAME   VALUE TYPE EXAMPLE / FORMAT

title        string         "My New Post"
description  string         "A short description"
category     string         "my favorite recipes"
date         string         "YYYY-MM-DD [HH:MM]"
author       string/array   See author section
image        string/array   See image section

Note that YAML here is pretty forgiving. In most cases you do not need to wrap strings in quotes,
but it can help in certain edge cases, for example if the text contains special Yaml characters, thus they are included here.

In the examples below, when there are multiple examples, they signify various ways to use the same property.

When specifying an array you don't need all the sub-properties. The examples generally show all the supported values.

Title

title: "My New Post"

Description

description: "A short description used in previews and SEO"

Category

category: blog

category: "My favorite recipes"

Date

date: "2022-01-01"

date: "2022-01-01 12:00"

Author

Specify a page author, either by a username for an author defined in the authors config, or by an arbitrary name,
or by an array of author data. See the Post Author section for more details.

Arbitrary name displayed "as is"

author: "Mr. Hyde"

Username defined in authors config

author: mr_hyde

Array of author data

author:
    name: "Mr. Hyde"
    username: mr_hyde
    website: https://twitter.com/HydeFramework

When specifying an array you don't need all the sub-properties. The example just shows all the supported values.
Array values here will override all the values in the authors config entry.

Image

Specify a cover image for the post, either by a local image path for a file in the _media/ directory, or by a full URL.
Any array data is constructed into a dynamic fluent caption, and injected into post and page metadata.

Local image path

When supplying an image source with a local image path, the image is expected to be stored in the _media/ directory.
Like all other media files, it will be copied to _site/media/ when the site is built, so Hyde will resolve links accordingly.

image: image.jpg

Full URL

Full URL starting with http(s)://) or // (protocol-relative).
The image source will be used as-is, and no additional processing is done.

image: https://cdn.example.com/image.jpg

Data-rich image

You can also supply an array of data to construct a rich image with a fluent caption.

image:
    source: Local image path or full URL
    altText: "Alt text for image"
    titleText: "Tooltip title"
    copyright: "Copyright (c) 2022"
    licenseName: "CC-BY-SA-4.0"
    licenseUrl: https://example.com/license/
    authorUrl: https://photographer.example.com/
    authorName: "John Doe"

See posts/introducing-images
for a detailed blog post with examples and schema information!
{ .info }

Using images in posts

To use images stored in the _media/ directory, you can use the following syntax:

Image Alt

Note the relative path since the blog post is compiled to posts/example.html

To learn more, check out the chapter in managing assets

Compile and Deploy your site

Compile and Deploy your site

Running the build command

Now that you have some amazing content, you'll want to compile your site into static HTML.

This is as easy as executing the build command:

php hyde build

You can also compile a single file:

php hyde rebuild 

And, you can even start a development server to compile your site on the fly:

php hyde serve

Further reading

info Key Concept: Autodiscovery When building the site, Hyde will use all the routes generated when the auto-discovery process scanned your source directories for files. The command will then compile them into static HTML using the appropriate layout depending on what kind of page it is. Thanks to Hyde, the days of manually defining routes are over!

Learn more about these commands in the console commands documentation:

- Build command
- Rebuild command
- Serve command

Deploying your site

One of the things that make static sites so enjoyable to work with is how easy it is to deploy them to the web.
This list is not exhaustive, but gives you a general idea of the most common ways to deploy your site.
If you have ideas to add to the documentation, please send a pull request!

General deployment

In essence, all you need to do is copy the contents of the _site directory to a web server, and you're done.

Once the site is compiled there is nothing to configure or worry about.

FTP and File Managers

If you have a conventional web host, you can use FTP/SFTP/FTPS to upload your compiled site files to the web server.
Some web hosting services also have web based file managers.

To deploy your site using any of these methods, all you need to do is upload the entire contents of your _site
directory to the web server's public document root, which is usually the public_html, htdocs, or www directory.

GitHub Pages - Manually

GitHub Pages is a free service that allows you to host your static site on the web.

In general, push the entire contents of your _site directory to the gh-pages branch of your repository,
or the docs/ directory on your main branch, depending on how you set it up.

Please see the GitHub Pages documentation for more information.

GitHub Pages - CI/CD

Hyde works amazing with GitHub Pages and GitHub Actions and the entire build and deploy process can be automated.

- We have a great blog post on how to do this, Automate HydePHP sites using GitHub Actions and GitHub Pages.

- You can also copy our sample GitHub Actions Workflow.yml file.

By the way, HydePHP.com is hosted on GitHub Pages, and the site is compiled in a GitHub Action workflow that compiles and
deploys the site automatically when the source is updated using this GitHub workflow.

Creating Documentation Pages

Creating Documentation Pages

Introduction to Hyde Documentation Pages

Welcome to the Hyde Documentation Pages, where creating professional-looking documentation sites has never been easier.
Using the Hyde Documentation module, all you need to do is place standard Markdown files in the _docs/ directory, and Hyde takes care of the rest.

Hyde compiles your Markdown content into beautiful static HTML pages using a TailwindCSS frontend, complete with a
responsive sidebar that is automatically generated based on your Markdown files. You can even customize the order,
labels, and even groups, of the sidebar items to suit your needs.

Additionally, if you have a _docs/index.md file, the sidebar header will link to it, and an automatically generated
"Docs" link will be added to your site's main navigation menu, pointing to your documentation page.

If you have a Torchlight API token in your .env file, Hyde will even enable syntax highlighting automatically,
saving you time and effort. For more information about this feature, see the extensions page.

Best Practices and Hyde Expectations

Since Hyde does a lot of things automatically, there are some things you may need
to keep in mind when creating blog posts so that you don't get unexpected results.

Filenames

- Hyde Documentation pages are files are stored in the _docs directory
- The filename is used as the filename for the compiled HTML
- Filenames should use kebab-case-name format, followed by the appropriate extension
- Files prefixed with _underscores are ignored by Hyde
- You should always have an index.md file in the _docs/ directory
- Your page will be stored in _site/docs/.html unless you change it in the config

Advanced usage and customization

Like most of HydePHP, the Hyde Documentation module is highly customizable. Much of the frontend is composed using Blade templates and components, which you can customize to your heart's content.
Since there are so many components, it's hard to list them all here in the documentation, so I encourage you to check out the source code to see how it's all put together and find the customizations you are looking for.

Creating Documentation Pages

You can create a Documentation page by adding a file to the _docs directory where the filename ends in .md.

You can also scaffold one quickly by using the HydeCLI.

php hyde make:page "Page Title" --type="docs"

This will create the following file saved as _docs/page-title.md

Page Title

Front Matter is optional

You don't need to use front matter to create a documentation page.

However, Hyde still supports front matter here as it allows you to quickly override the default values.

Here is a quick reference, however, you should take a look at the dynamic content section to learn more.

title: "Page Title"
navigation:
    label: "Sidebar Label"
    hidden: true
    priority: 5

Dynamic content generation

Hyde makes documentation pages easy to create by automatically generating dynamic content such as the sidebar and page title.
If you are not happy with the results you can customize them in the config or with front matter.

Front Matter reference

Before we look at how to override things, here is an overview of the relevant content Hyde generates,
and where the data is from as well as where it can be overridden.

Property                        Description                                            Dynamic Data Source                 Override in

title (string)                The title of the page used in the HTML ` tag   The first H1 heading (# Foo`)      Front matter
navigation.label (string)     The label for the page shown in the sidebar            The page basename Front matter, config
navigation.priority (integer) The priority of the page used for ordering the sidebar Defaults to 999                     Front matter, config
navigation.hidden (boolean)   Hides the page from the sidebar                        none                              Front matter, config
navigation.group (string)     The group the page belongs to in the sidebar           Subdirectory, if nested             Front matter

Sidebar

The sidebar is automatically generated from the files in the _docs directory. You will probably want to change the order
of these items. You can do this in two ways, either in the config or with front matter using the navigation array settings.

Table of contents

Hyde automatically generates a table of contents for the page and adds it to the sidebar.

The behaviour of this can be changed in the configuration file.
See the customization page for more details.

Sidebar ordering

The sidebar is sorted/ordered by the priority property. The higher the priority the further down in the sidebar it will be.
The default priority is 999. You can override the priority using the following front matter:

navigation:
    priority: 5

You can also change the order in the Docs configuration file.
See the chapter in the customization page for more details. 
I personally think the config route is easier as it gives an instant overview, however the first way is nice as well.

Sidebar labels

The sidebar items are labeled with the label property. The default label is the filename of the file.
You can change it with the following front matter:

navigation:
    label: "My Custom Sidebar Label"

Sidebar grouping

Sidebar grouping allows you to group items in the sidebar into categories. This is useful for creating a sidebar with a lot of items.
The Hyde docs for instance use this.

The feature is enabled automatically when one or more of your documentation pages have the navigation.group property set
in the front matter. This will then switch to a slightly more compact sidebar layout with pages sorted into categories.
Any pages without the group front matter will get put in the "Other" group.

Sidebar footer customization

The sidebar footer contains, by default, a link to your site homepage. You can change this in the config/docs.php file.

// filepath: config/docs.php

'sidebar' => [
    'footer' => 'My Markdown Footer Text',
],

You can also set the option to false to disable it entirely.

Using Front Matter

To enable sidebar grouping, you can add the following front matter to your documentation pages:

navigation:
    group: "Getting Started"

Automatic subdirectory-based grouping

You can also automatically group your documentation pages by placing source files in sub-directories.

For example, putting a Markdown file in _docs/getting-started/, is equivalent to adding the same front matter seen above.

info Note that when the flattened output paths setting is enabled (which it is by default), the file will still be compiled to the _site/docs/ directory like it would be if you didn't use the subdirectories.

Hiding items

You can hide items from the sidebar by adding the hidden property to the front matter:

navigation:
    hidden: true

This can be useful to create redirects or other items that should not be shown in the sidebar.

info The index page is by default not shown as a sidebar item, but instead is linked in the sidebar header. 

Customization

Please see the customization page for in-depth information on how to customize Hyde,
including the documentation pages. Here is a high level overview for quick reference though.

Output directory

If you want to store the compiled documentation pages in a different directory than the default 'docs' directory,
for example to specify a version like the Hyde docs does, you can specify the output directory in the Hyde configuration file.
The path is relative to the site output, typically _site.

// filepath: config/hyde.php
'output_directories' => [
    \Hyde\Pages\DocumentationPage::class => 'docs' // default [tl! --]
    \Hyde\Pages\DocumentationPage::class => 'docs/1.x' // What the Hyde docs use [tl! ++]
]

Note that you need to take care as to not set it to something that may conflict with other parts, such as media or posts directories.

Automatic navigation menu

By default, a link to the documentation page is added to the navigation menu when an index.md file is found in the _docs directory. Please see the customization page for more information.

Sidebar header name

By default, the site title shown in the sidebar header is generated from the configured site name suffixed with "docs".
You can change this in the Docs configuration file. Tip: The header will link to the docs/index page, if it exists.

'title' => 'API Documentation',

Sidebar page order

To quickly arrange the order of items in the sidebar, you can reorder the page identifiers in the list and the links will be sorted in that order.
Link items without an entry here will have fall back to the default priority of 999, putting them last.

'sidebar_order' => [
    'readme',
    'installation',
    'getting-started',
]

See the chapter in the customization page for more details. 

Automatic sidebar group labels

When using the automatic sidebar grouping feature (based on subdirectories), the titles of the groups are generated from the directory names.
If these are not to your liking, for example if you need to use special characters, you can override them in the Docs configuration file.
The array key is the directory name, and the value is the label.

Please note that this option is not added to the config file by default, as it's not a super common use case. No worries though, just add the following yourself!

// Filepath: config/docs.php

'sidebargrouplabels' => [
    'questions-and-answers' => 'Questions & Answers',
],

Table of contents settings

In the config/docs.php file you can configure the behavior, content, and the look and feel of the sidebar table of contents.
You can also disable the feature completely.

'tableofcontents' => [
    'enabled' => true,
    'minheadinglevel' => 2,
    'maxheadinglevel' => 4,
    'smoothpagescrolling' => true,
],

Using flattened output paths

If this setting is set to true, Hyde will output all documentation pages into the same configured documentation output directory.
This means that you can use the automatic directory based grouping feature, but still have a "flat" output structure.
Note that this means that you can't have two documentation pages with the same filename or navigation menu label as they will overwrite each other.

If you set this to false, Hyde will match the directory structure of the source files (just like all other pages).

// Filepath: config/docs.php
'flattenedoutputpaths' => true,

Search feature

Introduction

The HydeSearch plugin adds a search feature to documentation pages. It consists of two parts, a search index generator
that runs during the build command, and a frontend JavaScript plugin that adds the actual search widget.

info Tip: The HydeSearch plugin is what powers the search feature on this site! Why not try it out!

The search feature is enabled by default. You can disable it by removing the documentationSearch from the Hyde Features config array.

// filepath: config/hyde.php
'features' => [
    Features::documentationSearch(), // [tl! --]
],

Using the search

The search works by generating a JSON search index which the JavaScript plugin loads asynchronously.

Two ways to access the search are added, one is a full page search screen that will be saved to docs/search.html.

The second method is a button added to the documentation pages, similar to how Algolia DocSearch works.
Opening it will open a modal with an integrated search screen. You can also open the dialog using the keyboard shortcut /.

info The full page can be disabled by setting createsearchpage to false in the docs config.

Hiding pages from indexing

If you have a large page on your documentation site, like a changelog, you may want to hide it from the search index.
You can do this by adding the page identifier to the excludefromsearch array in the docs config, similar to how
navigation menu items are hidden. The page will still be accessible as normal but will be added to the search index JSON file.

// filepath: config/docs.php
'excludefromsearch' => [
  'changelog',
]

Live search with the realtime compiler

The Realtime Compiler that powers the php hyde serve command will automatically generate a fresh search index each time the browser requests it.

Automatic "Edit Page" button

Introduction

Hyde can automatically add links to documentation pages that takes the user
to a GitHub page (or similar) to edit the page. This makes it great for open-source projects
looking to allow others to contribute to the documentation in a quick and easy manner.

The feature is automatically enabled when you specify a base URL in the Docs configuration file.
Hyde expects this to be a GitHub path, but it will probably work with other methods as well,
if not, please send a PR and/or create an issue on the GitHub repository!

info Tip: This documentation site uses this feature, scroll down to the bottom of this page and try it out!

Configuration

As an example configuration, let's take a practical example for how HydePHP.com uses this feature.

// Filepath: config/docs.php

'sourcefilelocation_base' => 'https://github.com/hydephp/docs/blob/master/',

Changing the button text

Changing the label is easy, just change the following config setting:

// Filepath: config/docs.php
'editsourcelink_text' => 'Edit Source on GitHub',

Changing the position

By default, the button will be shown in both the documentation page footer.
You can change this by setting the following config setting to 'header', 'footer', or 'both'

// Filepath: config/docs.php
'editsourcelink_position' => 'header',

Adding a button icon

This is not included out of the box, but is easy to add with some CSS!
Just target the .edit-page-link class.

// filepath e.g. app.css
.edit-page-link::before {content: "✏ "}

Changing the Blade view

You can also publish the edit-source-button.blade.php view and change it to your liking.

