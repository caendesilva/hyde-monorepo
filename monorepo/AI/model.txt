Start HydePHP Documentation (Framework version v1.3.3)

--- digging-deeper/updating-hyde.md ---


# Updating Hyde Projects

This guide will help you update your HydePHP project to the latest version.


## Before you start

When updating an existing installation, first ensure that you have a backup of your project in case anything goes wrong.
The recommended way to do this is to use Git as that allows you to smoothly roll back any changes.


## Methods

### Which method?

Depending on how you installed Hyde, there are a few different ways to update it.

We have a few methods documented here. The [Git method](#using-git) is recommended as it is the easiest and safest way to
update your project. If you are not using Git, you can still update your project using any of the [manual methods](#manual-update).

Regardless of the method you use, make sure you follow the [post-update instructions](#post-update-instructions) at the end.

### Using Git

First, make sure you have a remote set up for the base project repository.

```bash
git remote add upstream https://github.com/hydephp/hyde.git
```

Then pull the latest release from the upstream repository.

```bash
git pull upstream master
```

After this, you should update your composer dependencies:

```bash
composer update
```

Next, follow the post-update instructions.

### Manual Update

If you are not using Git, you can still update your project. This is a bit more involved, but it is still possible.

1. First, you will need to download the latest release archive from the [releases page](https://github.com/hydephp/hyde/releases).
2. Then extract the archive, and copy the contents into your project directory.

Since this may overwrite modified files, it may be safer to use the [hard update](#hard-update) method.

### Hard Update

If you are having trouble updating your project, you can try a hard update. In short, this approach consists of creating
a brand new project and copying over only your source and resource files. If you do not want to use Git, this may be
the safest option as you won't be overriding any of your existing files.

If you have changed any other files, for example in the App directory, you will need to update those files manually as well.
The same goes if you have created any custom Blade components or have modified Hyde ones.

**Here is an example CLI workflow, but you can do the same using a graphical file manager.**

```bash
mv my-project my-project-old
composer create-project hyde/hyde my-project

cp -r my-old-project/_pages my-project/content/_pages
cp -r my-old-project/_posts my-project/content/_posts
cp -r my-old-project/_media my-project/content/_media
cp -r my-old-project/_docs my-project/content/_docs
cp -r my-old-project/config my-project/config
```

Next, follow the post-update instructions. After verifying that everything is working, you can delete the old project directory.


## Post-update instructions

After updating Hyde you should update your config and resource files. This is where things can get a tiny bit dangerous
as existing files may be overwritten. If you are using Git, you can easily take care of any merge conflicts that arise.

First, ensure that your dependencies are up to date. If you have already done this, you can skip this step.

```bash
composer update
```

Then, update your config files. This is the hardest part, as you may need to manually copy in your own changes.

```bash
php hyde publish:configs
```

If you have published any of the included Blade components you will need to re-publish them.

```bash
php hyde publish:views layouts
php hyde publish:views components
```

Next, recompile your assets, if you are not using the built-in assets.

```bash
npm install
npm run dev/prod
```

Finally, you can rebuild your site.

```bash
php hyde build
```


--- digging-deeper/collections.md ---


Lorem ipsum dolor sit amet, consectetur adipiscing elit...
```

Let's take a look at our directory structure. I just copied the same file a few times.
You can name the files anything you want, I kept it simple and just numbered them.

```tree
resources/collections
└── testimonials
    ├── 1.md
    ├── 2.md
    └── 3.md
```

#### Using the Facade to Access the Collections

Now for the fun part! We will use the `DataCollections::markdown()` to access all our files into a convenient object.
The class is registered with an alias, so you don't need to include any namespaces when in a Blade file.

The general syntax to use the facade is as follows:

```blade
DataCollections::markdown('subdirectory_name')
```

This will return a Hyde DataCollections object, containing our Markdown files as MarkdownDocument objects. Here is a quick look at the object the facade returns:

<pre style="display: block; white-space: pre-wrap; padding: 1rem 1.5rem; overflow: initial !important; background-color: rgb(24, 23, 27); color: rgb(255, 132, 0); font: 400 12px Menlo, Monaco, Consolas, monospace; overflow-wrap: break-word; position: relative; z-index: 99999; word-break: break-all; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><span class="sf-dump-default" style="display: inline; background-color: rgb(24, 23, 27); color: rgb(255, 132, 0); font: 12px Menlo, Monaco, Consolas, monospace; overflow-wrap: break-word; white-space: pre-wrap; position: relative; z-index: 99999; word-break: break-all;">^</span><span class="sf-dump-default" style="display: inline; background-color: rgb(24, 23, 27); color: rgb(255, 132, 0); font: 12px Menlo, Monaco, Consolas, monospace; overflow-wrap: break-word; white-space: pre-wrap; position: relative; z-index: 99999; word-break: break-all;"> </span><span style="display: inline; color: rgb(18, 153, 218);">Hyde\Support\DataCollections</span> {<span style="text-decoration: none; border: 0px; outline: none; color: rgb(160, 160, 160);">#651 <span style="display: inline;">▼</span></span><samp>
  #<span style="display: inline; color: rgb(255, 255, 255);">items</span>: <span style="display: inline; color: rgb(18, 153, 218);">array:3</span> [<span style="text-decoration: none; border: 0px; outline: none; color: rgb(160, 160, 160);"><span style="display: inline;">▼</span></span><samp>
    "<span style="display: inline; color: rgb(86, 219, 58);">testimonials/1.md</span>" =&gt; <span style="display: inline; color: rgb(18, 153, 218);"><span>Hyde\Markdown\Models</span><span style="display: inline-block; text-overflow: ellipsis; max-width: none; white-space: nowrap; overflow: hidden; vertical-align: top; color: rgb(18, 153, 218);">\</span>MarkdownDocument</span> {<span style="text-decoration: none; border: 0px; outline: none; color: rgb(160, 160, 160);">#653 <span style="display: inline;">▼</span></span><samp>
      +<span style="display: inline; color: rgb(255, 255, 255);">matter</span>: <span style="display: inline; color: rgb(18, 153, 218);"><span>Hyde\Markdown\Models</span><span style="display: inline-block; text-overflow: ellipsis; max-width: none; white-space: nowrap; overflow: hidden; vertical-align: top; color: rgb(18, 153, 218);">\</span>FrontMatter</span> {<span style="text-decoration: none; border: 0px; outline: none; color: rgb(160, 160, 160);">#652 <span style="display: inline;">▶</span></span>}
      +<span style="display: inline; color: rgb(255, 255, 255);">markdown</span>: <span style="display: inline; color: rgb(18, 153, 218);"><span>Hyde\Markdown\Models</span><span style="display: inline-block; text-overflow: ellipsis; max-width: none; white-space: nowrap; overflow: hidden; vertical-align: top; color: rgb(18, 153, 218);">\</span>Markdown</span> {<span style="text-decoration: none; border: 0px; outline: none; color: rgb(160, 160, 160);">#654 <span style="display: inline;">▶</span></span>}
    </samp>}
    "<span style="display: inline; color: rgb(86, 219, 58);">testimonials/2.md</span>" =&gt; <span style="display: inline; color: rgb(18, 153, 218);"><span>Hyde\Markdown\Models</span><span style="display: inline-block; text-overflow: ellipsis; max-width: none; white-space: nowrap; overflow: hidden; vertical-align: top; color: rgb(18, 153, 218);">\</span>MarkdownDocument</span> {<span style="text-decoration: none; border: 0px; outline: none; color: rgb(160, 160, 160);">#656 <span style="display: inline;">▶</span></span>}
    "<span style="display: inline; color: rgb(86, 219, 58);">testimonials/3.md</span>" =&gt; <span style="display: inline; color: rgb(18, 153, 218);"><span>Hyde\Markdown\Models</span><span style="display: inline-block; text-overflow: ellipsis; max-width: none; white-space: nowrap; overflow: hidden; vertical-align: top; color: rgb(18, 153, 218);">\</span>MarkdownDocument</span> {<span style="text-decoration: none; border: 0px; outline: none; color: rgb(160, 160, 160);">#659 <span style="display: inline;">▶</span></span>}
  </samp>]
</samp>}
</pre>

#### Implementing it in a Blade view

Let's create a Blade page to display all our testimonials.

```bash
php hyde make:page "Testimonials" --type="blade"
```

And we can use the collection almost like any other Laravel one. As you can see, since each entry is a `MarkdownDocument` class,
we are able to get the author from the front matter, and the content from the body.

```blade
// filepath _pages/testimonials.blade.php
@foreach(DataCollections::markdown('testimonials') as $testimonial)
    <blockquote>
        <p>{{ $testimonial->body }}</p>
        <small>{{ $testimonial->matter['author'] }}</small>
    </blockquote>
@endforeach
```


--- digging-deeper/troubleshooting.md ---


# Troubleshooting

Since Hyde has a lot of "magic" features which depend on some base assumptions,
there might be some "gotchas" you might run into. Here are some I can think of,
did you find a new one? Send a PR to [update the docs](https://github.com/hydephp/docs)!

>info Tip: You can run `php hyde validate` to run a series of tests to help you catch common issues.


## General Tips

(In no particular order of importance)

1. In general, **Hyde is actually pretty forgiving**. While this article makes it sound like there are a lot of rules to follow,
   honestly don't worry about it. Hyde will attempt to fix mistakes and make your life easier.
2. You don't need to set an H1 heading in blog posts. The H1 is set by Hyde based on the front matter title.
3. You never need front matter, though it is often useful.
   For example, Hyde makes attempts to guess the title for a page depending on the content. (Headings, filenames, etc).


## Conventions to follow

### File naming

For Hyde to be able to discover your files, you should follow the following conventions.

Markdown files should have the extension `.md`. Blade files should have the extension `.blade.php`.

Unexpected behaviour might occur if you use conflicting file names.
All the following filenames are resolved into the same destination file:
`foo-bar.md`, `Foo-Bar.md`, `foo-bar.blade.php`, causing only one of them to be saved.

Remember, files retain their base filenames when compiled to HTML.

#### Summary

- ✔ **Do** use lowercase filenames and extensions
- ✔ **Do** use filenames written in kebab-case-format
- ✔ **Do** use the proper file extensions
- ❌ **Don't** use conflicting source file names


## Extra Information

### Definitions

We will use the following definitions to describe the behaviour of Hyde.

#### General

- **Hyde**: The application that you are using.
- **HydeCLI**: The command-line interface for Hyde.
- **Framework**: The package containing the core codebase.

#### Path components

- **Identifier**: The filepath without the extension, relative to the page type source directory.
- **Route Key**: The page type's output directory plus the identifier. Example: `posts/hello-world`
- **Basename**: The filename without the extension. Example: `hello-world`
- **Filename**: The full name of a file with the extension. Example: `hello-world.md`
- **Filepath**: The full file path including extension. Example: `_posts/hello-world.md`

You can read more about some of these in the [Core Concepts](core-concepts#paths-identifiers-and-route-keys) article.


## Common issues, causes, and solutions

| Issue                                              | Possible Cause / Issue Context                                                                                                                            | Possible Solution                                                                                                                                                                                 |
|----------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 404 error when visiting site                       | Are you missing an index file in the `_pages` directory?                                                                                                  | Add an `index.md` or `index.blade.php` to the `_pages` directory                                                                                                                                  |
| Navigation menu not linking to the docs            | You probably don't have an `index.md` file in the `_docs` directory.                                                                                      | Create a `_docs/index.md` file                                                                                                                                                                    |
| Page not discovered when compiling                 | The file name may be invalid                                                                                                                              | Ensure you follow the correct file naming convention.                                                                                                                                             |
| Page compiles slowly                               | The Torchlight extension may cause the compile times to increase as API calls need to be made.                                                            | Try disabling Torchlight                                                                                                                                                                          |
| Torchlight not working                             | Missing Composer package, missing API token, extension disabled in the config.                                                                            | Reinstall Torchlight, add your token in the `.env` file, check config                                                                                                                             |
| Missing styles and/or assets                       | You may have accidentally deleted the files, or you have added new Tailwind classes.                                                                      | Run `npm run dev`                                                                                                                                                                                 |
| Image not found                                    | You may be using a bad relative path.                                                                                                                     | Ensure your relative paths are correct.  See [managing-assets](managing-assets#referencing-images).                                                                                               |
| Wrong layout used                                  | Hyde determines the layout template to use depending on the directory of the source file                                                                  | Ensure your source file is in the right directory.                                                                                                                                                |
| Invalid/no permalinks or post URIs                 | You may be missing or have an invalid site URL                                                                                                            | Set the site URL in the `.env` file                                                                                                                                                               |
| No styles in custom Blade pages                    | When using custom blade pages need to add the styles yourself. You can do this by extending the default layout                                            | Use the app layout, or by include the Blade components directly.                                                                                                                                  |
| Overriding Hyde views is not working               | Ensure the Blade views are in the correct directory.                                                                                                      | Rerun `php hyde publish:views`.                                                                                                                                                                   |
| Styles not updating when deploying site            | It could be a caching issue. To be honest, when dealing with styles, it's always a caching issue.                                                         | Clear your cache, and optionally complain to your site host                                                                                                                                       |
| Documentation sidebar items are in the wrong order | Double check the config, make sure the route keys are written correctly. Check that you are not overriding with front matter.                             | Check config for typos and front matter                                                                                                                                                           |
| Documentation table of contents is weird           | The table of contents markup is generated by the [League/CommonMark extension](https://commonmark.thephpleague.com/2.3/extensions/table-of-contents/)     | Make sure that your Markdown headings make sense                                                                                                                                                  |
| Issues with date in blog post front matter         | The date is parsed by the PHP `strtotime()` function. The date may be in an invalid format, or the front matter is invalid                                | Ensure the date is in a format that `strtotime()` can parse. Wrap the front matter value in quotes.                                                                                               |
| RSS feed not being generated                       | The RSS feed requires that you have set a site URL in the Hyde config or the `.env` file. Also check that you have blog posts, and that they are enabled. | Check your configuration files.                                                                                                                                                                   |                                                                                                                                                         |
| Sitemap not being generated                        | The sitemap requires that you have set a site URL in the Hyde config or the `.env` file.                                                                  | Check your configuration files.                                                                                                                                                                   |                                                                                                                                                         |
| Unable to do literally anything                    | If everything is broken, you may be missing a Composer package or your configuration files could be messed up.                                            | Run `composer install` and/or `composer update`. If you can run HydeCLI commands, update your configs with `php hyde publish:configs`, or copy them manually from GitHub or the vendor directory. |

### Extra troubleshooting information

#### Fixing a broken config

If your configuration is broken, you might not be able to run any commands through the HydeCLI.
To remedy this you can copy the config files from the vendor directory into the project directory.
You can do this manually, or with the following rescue command:

```bash
copy vendor/hyde/framework/config/hyde.php config/hyde.php
```


--- digging-deeper/customization.md ---


#### Adding Custom Navigation Menu Links

You can easily add custom navigation menu links similar how we add Authors. Simply add a `NavItem` model to the `navigation.custom` array.

When linking to an external site, you should use the `NavItem::forLink()` method facade. The first two arguments are the
destination and label, both required. Third argument is the priority, which is optional, and defaults to 500.

```php
// filepath config/hyde.php
use Hyde\Framework\Features\Navigation\NavItem;

'navigation' => [
    'custom' => [
        NavItem::forLink('https://github.com/hydephp/hyde', 'GitHub', 200),
    ]
]
```

Simplified, this will then be rendered as follows:

```html
<a href="https://github.com/hydephp/hyde">GitHub</a>
```

## Blade Views

Hyde uses the Laravel Blade templating engine. Most parts of the included templates have been extracted into components to be customized easily.
Before editing the views you should familiarize yourself with the [Laravel Blade Documentation](https://laravel.com/docs/10.x/blade).

To edit a default Hyde component you need to publish them first using the `hyde publish:views` command.

```bash
php hyde publish:views
```

The files will then be available in the `resources/views/vendor/hyde` directory.

## Frontend Styles

Hyde is designed to not only serve as a framework but a whole starter kit and comes with a Tailwind starter template
for you to get up and running quickly. If you want to customize these, you are free to do so.
Please see the [Managing Assets](managing-assets) page to learn more.

## Markdown Configuration

Hyde uses [League CommonMark](https://commonmark.thephpleague.com/) for converting Markdown into HTML, and
uses the GitHub Flavored Markdown extension. The Markdown related settings are found in the `config/markdown.php` file.
Below follows an overview of the Markdown configuration options available in Hyde.

### CommonMark Extensions

You can add any extra [CommonMark Extensions](https://commonmark.thephpleague.com/2.3/extensions/overview/),
or change the default ones, using the `extensions` array in the config file. They will then automatically be loaded into
the CommonMark converter environment when being set up by Hyde.

```php
// filepath: config/markdown.php
'extensions' => [
    \League\CommonMark\Extension\GithubFlavoredMarkdownExtension::class,
    \League\CommonMark\Extension\Attributes\AttributesExtension::class,
],
```

Remember that you may need to install any third party extensions through Composer before you can use them.

### CommonMark Configuration

In the same file you can also change the configuration values to be passed to the CommonMark converter environment.
Hyde handles many of the options automatically, but you may want to override some of them and/or add your own.

```php
// filepath: config/markdown.php
'config' => [
    'disallowed_raw_html' => [
        'disallowed_tags' => [],
    ],
],
```

See the [CommonMark Configuration Docs](https://commonmark.thephpleague.com/2.3/configuration/) for the available options.
Any custom options will be merged with the defaults.

### Allow Raw HTML

Since Hyde uses [GitHub Flavored Markdown](https://commonmark.thephpleague.com/2.3/extensions/github-flavored-markdown/),
some HTML tags are stripped out by default. If you want to allow all arbitrary HTML tags, and understand the risks involved,
you can use the `allow_html` setting to enable all HTML tags.

```php
// filepath: config/markdown.php
'allow_html' => true,
```

### Allow Blade Code

HydePHP also allows you to use Blade code in your Markdown files. This is disabled by default, since it allows
arbitrary PHP code specified in Markdown to be executed. It's easy to enable however, using the `enable_blade` setting.

```php
// filepath: config/markdown.php
'enable_blade' => true,
```

See the [Blade in Markdown](advanced-markdown#blade-support) documentation for more information on how to use this feature.

## YAML Configuration

The settings in the `config/hyde.php` file can also be set by using a `hyde.yml` file in the root of your project directory.

Note that YAML settings cannot call any PHP functions, so you can't access helpers like `env()` for environment variables,
nor declare authors or navigation links, as you cannot use facades and objects. But that doesn't stop you from using both
files if you want to. Just keep in mind that any duplicate settings in the YAML file override any made in the PHP file.

Here is an example showing some of the `config/hyde.php` file settings, and how they would be set in the YAML file.

```yaml
# filepath hyde.yml
name: HydePHP
url: "http://localhost"
pretty_urls: false
generate_sitemap: true
rss:
  enabled: true
  filename: feed.xml
  description: HydePHP RSS Feed
language: en
output_directory: _site
```

### Namespaced YAML Configuration

If you are running `v1.2` or higher, you can also use namespaced configuration options in the YAML file.

This allows you to set the settings of **any** configuration file normally found in the `config` directory.

This feature is automatically enabled when you have a `hyde:` entry **first** in your `hyde.yml` file

```yaml
# filepath hyde.yml
hyde:
  name: HydePHP

docs:
  sidebar:
    header: "My Docs"
```

This would set the `name` setting in the `config/hyde.php` file, and the `sidebar.header` setting in the `config/docs.php` file.

Each top level key in the YAML file is treated as a namespace, and the settings are set in the corresponding configuration file.
You can of course use arrays like normal even in namespaced configuration.


--- digging-deeper/advanced-customization.md ---


# Advanced Customization

## Introduction

This page covers advanced usage and is intended for developers who know what they are doing. Documentation here will be
mainly example driven, as it is assumed you have somewhat of an understanding of what you are doing already.

### Prerequisites for Customizing directories

>info Before customizing source and output directories it may be helpful to know how these settings are stored internally.

**The following is a summary from the [Page Models](page-models) documentation:**

Each page type is represented by a page model class. Each of those classes have static properties that store the source and output directories.
These properties are set when the [`HydeServiceProvider`](https://github.com/hydephp/framework/blob/master/src/Framework/HydeServiceProvider.php)
is registered, at which point the provider will search for any overrides in the config file.

**This means that there are two options to change the source and output directories:**
1. **Recommended:** You can change the values in the config file, to let the `HydeServiceProvider` handle it for you.
2. **Advanced/Overkill:** You can also set the static properties directly in the page model classes if you prefer.
   - You'd probably want to do this in a service provider, as it must be done before the Kernel is booted.
   - You can use the [`RegistersFileLocations`](https://github.com/hydephp/framework/blob/master/src/Framework/Concerns/RegistersFileLocations.php)
     trait to use the same registration logic as the `HydeServiceProvider`.


## Customizing source directories

The directories you place your content in are important. The directory will be used to determine the proper page type and the templates used.
If you are not happy with defaults, you can change them. Note that these are relative to the `source_root` setting,
which is the root of your project by default.

Note that you need to take care of conflicts when changing the source directories. For example, if you store Markdown
posts in the same directory as documentation pages, Hyde will not know which page type to use.

### In the config file

```php
// filepath config/hyde.php

'source_directories' => [
    HtmlPage::class => '_pages',
    BladePage::class => '_pages',
    MarkdownPage::class => '_pages',
    MarkdownPost::class => '_posts',
    DocumentationPage::class => '_docs',
],
```

### In a service provider

```php
// filepath app/AppServiceProvider.php
use Hyde\Framework\Concerns\RegistersFileLocations;

public function register(): void
{
    $this->registerSourceDirectories([
        HtmlPage::class => '_pages',
        BladePage::class => '_pages',
        MarkdownPage::class => '_pages',
        MarkdownPost::class => '_posts',
        DocumentationPage::class => '_docs',
    ]);
}
```


## Customizing output directories

Like source directories, the output directories are also important as they determine the output path for the compiled pages.
>warning Note that changing output directories also affects the route keys, as those are based on the output directory. <p>Scroll down to see the [Route key impact](#route-key-impact) section for more information.</p>

Each option is relative to the site's `output_directory` setting. Setting a value to `''` will output the page to the site root.

### In the config file

```php
// filepath config/hyde.php
'output_directories' => [
    HtmlPage::class => '',
    BladePage::class => '',
    MarkdownPage::class => '',
    MarkdownPost::class => 'posts',
    DocumentationPage::class => 'docs',
],
```

### In a service provider

```php
// filepath app/AppServiceProvider.php
use Hyde\Framework\Concerns\RegistersFileLocations;

public function register(): void
{
    $this->registerOutputDirectories([
        HtmlPage::class => '',
        BladePage::class => '',
        MarkdownPage::class => '',
        MarkdownPost::class => 'posts',
        DocumentationPage::class => 'docs',
    ]);
}
```

### Route key impact

For example, changing the output directory of Markdown posts to `blog` instead of `posts` will change the route key base from `posts` to `blog`.
This means that a file stored as `_posts/hello-world.md` will have the route key `blog/hello-world` instead of `posts/hello-world`,
this may break your site's configuration, so you should always verify the impact to your site of such a change.
You can learn more about this in the [route key documentation](core-concepts#paths-identifiers-and-route-keys).


## Custom source root

HydePHP will by default look for the source directories shown above in the root of your project.
If you're not happy with this, it's easy to change! For example, you might want everything in a `'src'` subdirectory.
That's easy enough, just set the value of the `source_root` setting in `config/hyde.php` to `'src'`, or whatever you prefer!

```php
// filepath config/hyde.php

'source_root' => '', // [TL! --]
'source_root' => 'src', // [TL! ++]
```

### Automatic change

You can even make this change automatically with the `php hyde change:sourceDirectory` command!

```bash
php hyde change:sourceDirectory <name>
```

When run, Hyde will update the source directory setting in the config file, then create the directory if it doesn't exist,
and move all source directories and their content into it.


## Custom media directory

The media directory houses assets like images and stylesheets. The default directory is `_media`, and upon building the site,
Hyde will copy all files in this directory to `_site/media` (or whatever your configured output and media directories are).

You can change the path to this directory by setting the `media_directory` option in `config/hyde.php`.

```php
// filepath config/hyde.php
'media_directory' => '_media',
```

#### Next steps

1. Note that you will likely need to manually update `webpack.mix.js` so Laravel Mix can compile the assets correctly.
2. You will of course also need to copy over any existing files from the old directory to the new one.

#### Setting changes both source and output directories

Note that this change will affect both the source and output directories. For example, if you set the value to `assets`,
all files from `assets` will be copied to `_site/assets`. If the setting starts with an underscore, that will be removed
from the output directory, so files in `_assets` will be copied to `_site/assets`.


## Custom output directory

>danger <p><strong>Warning: Hyde deletes all files in the output directory before compiling the site.</strong></p> <p>Don't set this path to a directory that contains important files!</p>

If you want to store your compiled website in a different directory than the default `_site`, you can change the path
using the following configuration option in `config/hyde.php`. The path is expected to be relative to your project root.

```php
// filepath config/hyde.php
'output_directory' => '_site',
```


--- digging-deeper/advanced-markdown.md ---


# Advanced Markdown

## Introduction

Since HydePHP makes heavy use of Markdown, there are some extra features and helpers created just for Hyde to make using Markdown even easier and more powerful!


## Using Blade in Markdown

A special feature in Hyde, is that you can use [Laravel Blade](https://laravel.com/docs/10.x/blade) in Markdown files!

To use Blade in your Markdown files, simply use the Blade shortcode directive, followed by your desired Blade string.

### Standard syntax

```markdown
 [Blade]: {{ "Hello World!" }} // Will render: 'Hello World!'
```

### Blade includes

Only single-line shortcode directives are supported. If you need to use multi-line Blade code, use an `@include`
directive to render a more complex Blade template. You can pass data to includes by specifying an array to the second argument.

```markdown
 [Blade]: @include("hello-world")
 [Blade]: @include("hello", ["name" => "World"])
```

### Enabling Blade-supported Markdown

The feature is disabled by default since it allows arbitrary PHP to run, which could be a security risk, depending on your setup.
However, if your Markdown is trusted, and you know it's safe, you can enable it in the `config/markdown.php` file.

```php
// filepath: config/markdown.php
'enable_blade' => true,
```

### Limitations

All shortcodes must be the first word on a new line, and only single-line shortcodes are supported.


## Coloured Blockquotes

The HydePHP Markdown converter also supports some extra directives and features. One of them being four different
coloured blockquotes. Simply append the desired colour after the initial `>` character.

```markdown
‎> Normal Blockquote
‎>info Info Blockquote
‎>warning Warning Blockquote
‎>danger Danger Blockquote
‎>success Success Blockquote
```

> Normal Blockquote
>info Info Blockquote
>warning Warning Blockquote
>danger Danger Blockquote
>success Success Blockquote

### Customizations

You can easily customize these styles too by adding and editing the following in your `resources/app.css` file, and then recompiling your site styles.
The code examples here use the Tailwind `@apply` directives, but you could also use `border-color: something;` just as well.

```css
/* filepath resources/app.css

/* Markdown Features */

.prose blockquote.info {
    @apply border-blue-500;
}

.prose blockquote.success {
    @apply border-green-500;
}

.prose blockquote.warning {
    @apply border-amber-500;
}

.prose blockquote.danger {
    @apply border-red-600;
}
```

### Markdown usage

The coloured blockquotes also support inline Markdown, just like normal blockquotes.

```markdown
‎>info Formatting is **supported**!
```

### Limitations

Note that these currently do not support multi-line blockquotes.


## Code block filepaths

When browsing these documentation pages you may have noticed a label in the top right corner of code blocks specifying the file path.
These are also created by using a custom Hyde feature that turns code comments into automatic code blocks.

### Usage

Simply add a code comment with the path in the **first line** of a fenced code block like so:

````markdown
// Filepath: _docs/advanced-markdown.md
```php
‎// Filepath: hello-world.php

echo 'Hello World!';
```
````

Which becomes:

```php
// Filepath: hello-world.php

echo 'Hello World!';
```

### Alternative syntax

The syntax is rather forgiving, by design, and supports using both `//` and `#` for comments.
The colon is also optional, and the 'filepath' string is case-insensitive. So the following is also perfectly valid:

````markdown
```js
‎// filepath hello.js
console.log('Hello World!');
```
````

If you have a newline after the filepath, like in the first example, it will be removed so your code stays readable.

### Advanced usage

If you have enabled HTML in Markdown by setting the `allow_html` option to true in your `config/markdown.php` file,
anything within the path label will be rendered as HTML. This means you can add links, or even images to the label.

````markdown
// Filepath: <a href="https://github.com/hydephp/develop/blob/master/docs/digging-deeper/advanced-markdown.md" rel="nofollow noopener" target="_blank">View file on Github</a>
```markdown
‎// Filepath: <a href="https://github.com">View file on Github</a>
```
````

### Limitations

The filepaths are hidden on mobile devices using CSS to prevent them from overlapping with the code block.


## Configuration

### Full configuration reference

All Markdown-related configuration options are in the `config/markdown.php` file.
You can find the full reference on the [Customization](customization#markdown-configuration) page.

### Raw HTML Tags

To convert Markdown, HydePHP uses the GitHub Flavored Markdown extension, which strips out potentially unsafe HTML.
If you want to allow all arbitrary HTML tags, and understand the risks involved, you can enable all HTML tags by setting
the `allow_html` option to `true` in your `config/markdown.php` file.

```php
// filepath: config/markdown.php
'allow_html' => true,
```

This will add and configure the `DisallowedRawHtml` CommonMark extension so that no HTML tags are stripped out.

### Tailwind Typography Prose Classes

HydePHP uses the [Tailwind Typography](https://tailwindcss.com/docs/typography-plugin) to style rendered Markdown.
We do this by adding the `.prose` CSS class to the HTML elements containing the rendered Markdown, using the built-in Blade components.

You can easily edit these classes, for example if you want to customize the prose colours, in the `config/markdown.php` file.

```php
// filepath: config/markdown.php
'prose_classes' => 'prose dark:prose-invert', // [tl! remove]
'prose_classes' => 'prose dark:prose-invert prose-img:inline', // [tl! add]
```

Please note that if you add any new classes, you may need to recompile your CSS file.


--- extensions/third-party-integrations.md ---


# Integrations with third-party tools

## Torchlight

Torchlight is an amazing API for syntax highlighting, and is used by this site. I cannot recommend it highly enough,
especially for documentation sites and code-heavy blogs! As such, HydePHP has built-in support for Torchlight,
which is automatically enabled once you add an API token to your `.env` file. Nothing else needs to be done!

### Getting started

To get started you need an API token which you can get at [Torchlight.dev](https://torchlight.dev/).
It is entirely free for personal and open source projects, as seen on their [pricing page](https://torchlight.dev/#pricing).

When you have an API token, set it in the `.env` file in the root directory of your project.
Once a token is set, Hyde will automatically enable the CommonMark extension.

```env
TORCHLIGHT_TOKEN=torch_<your-api-token>
```

### Attribution and configuration

Note that for the free plan you need to provide an attribution link. Thankfully Hyde injects a customizable link
automatically to all pages that use Torchlight. You can of course disable and customize this in the `config/torchlight.php` file.

```php
'attribution' => [
    'enabled' => true,
    'markdown' => 'Syntax highlighting by <a href="https://torchlight.dev/" rel="noopener nofollow">Torchlight.dev</a>',
],
```

Don't have this file? Run `php hyde vendor:publish` to publish it.



--- extensions/extensions.md ---


# Extensions & Integrations

## HydePHP - Extensible by design

HydePHP is designed to be extensible, and comes with a number of built-in extensions and integrations,
as well as support for third-party extensions and integrations.

## First party extensions & integrations

### Realtime Compiler

The Hyde Realtime Compiler is included with Hyde installations and is what powers the `php hyde serve` command.
- Learn more about the [Realtime Compiler](realtime-compiler) in the documentation.

## Integrations with third-party tools

### Torchlight

Torchlight is an amazing API for syntax highlighting, and is supported natively by HydePHP.
- Learn more about [Torchlight](third-party-integrations#torchlight) in the documentation.

## Contribute

Have an idea for an extension or integration? Let me know! I'd love to hear from you. Get in touch on
[GitHub](https://github.com/hydephp/hyde) or send me a DM on [Twitter](https://twitter.com/CodeWithCaen).
You may also want to look at the [Extension API](extensions-api) documentation to learn how to create extensions.

--- extensions/realtime-compiler.md ---


# Realtime Compiler

The Hyde Realtime Compiler is included with Hyde installations and is what powers the `php hyde serve` command,
allowing you to preview your static site on a local development server without having to rebuild the site.

### Usage

To start the server, run the following command from a terminal in your project directory:

```bash
php hyde serve
```

This will start a local development server at `http://localhost:8080`

>warning Please note that the server is designed for local development, and should not be used on a public network.

### Configuration

The server can be configured in the `config/hyde.php` file to change the port, host, and to customize its features.

```php
// filepath config/hyde.php

'server' => [
    'port' => env('SERVER_PORT', 8080),
    'host' => env('SERVER_HOST', 'localhost'),
    'save_preview' => true,
],
```

### Live dashboard

#### Usage

The realtime compiler comes with a live dashboard that you can access at `http://localhost:8080/dashboard`.

From here, you can visually interact with your site content, including creating new pages and posts.

The live dashboard is not saved to your static site, and is only available through the development server.

#### Configuration

The dashboard can be customized, and disabled, in the `config/hyde.php` file.

```php
// filepath config/hyde.php

'server' => [
    'dashboard' => [
        'enabled' => env('SERVER_DASHBOARD', true),
        'interactive' => true,
        'tips' => true,
    ],
],
```

_The dashboard was added in Realtime Compiler v3.0.0 (March 2023), with interactive features added in v3.1.0 (October 2023)_

### Live edit

#### Usage

The live edit feature allows you to quickly edit Markdown-based pages (posts, docs, and pages) directly in the browser.

To enter the live editor, simply double-click on the article you want to edit, and it will be replaced with a text editor.
When you're done, click the save button to save the changes to the page's source file.

#### Shortcuts

The live editor supports the following keyboard shortcuts:
- `Ctrl + E` - Enter/Exit editor
- `Ctrl + S` - Save changes
- `esc` - Exit editor if active

#### Configuration

The live editor can be disabled in the `config/hyde.php` file.
The live editor plugin code will not be saved to your static site.

```php
// filepath config/hyde.php

'server' => [
    'live_edit' => env('SERVER_LIVE_EDIT', true),
],
```

_The live editor was added in Hyde Realtime Compiler Server v3.2.0 (November 2023)_

### Source code

- **GitHub**: [hydephp/realtime-compiler](https://github.com/hydephp/realtime-compiler)
- **Packagist**: [hydephp/realtime-compiler](https://packagist.org/packages/hyde/realtime-compiler)


--- creating-content/compile-and-deploy.md ---



## Deploying your site

One of the things that make static sites so enjoyable to work with is how easy it is to deploy them to the web.
This list is not exhaustive, but gives you a general idea of the most common ways to deploy your site.
If you have ideas to add to the documentation, please send a pull request!

### General deployment

In essence, all you need to do is copy the contents of the `_site` directory to a web server, and you're done.

Once the site is compiled there is nothing to configure or worry about.

### FTP and File Managers

If you have a conventional web host, you can use `FTP`/`SFTP`/`FTPS` to upload your compiled site files to the web server.
Some web hosting services also have web based file managers.

To deploy your site using any of these methods, all you need to do is upload the entire contents of your `_site`
directory to the web server's public document root, which is usually the `public_html`, `htdocs`, or `www` directory.

### GitHub Pages - Manually

GitHub Pages is a free service that allows you to host your static site on the web.

In general, push the entire contents of your `_site` directory to the `gh-pages` branch of your repository,
or the `docs/` directory on your main branch, depending on how you set it up.

Please see the [GitHub Pages documentation](https://help.github.com/pages/getting-started-with-github-pages/) for more information.

### GitHub Pages - CI/CD

Hyde works amazing with GitHub Pages and GitHub Actions and the entire build and deploy process can be automated.

- We have a great blog post on how to do this, [Automate HydePHP sites using GitHub Actions and GitHub Pages](https://hydephp.com/posts/github-actions-deployment).

- You can also copy our sample [GitHub Actions Workflow.yml file](https://github.com/hyde-staging/ci-demo/blob/master/.github/workflows/main.yml).

By the way, HydePHP.com is hosted on GitHub Pages, and the site is compiled in a GitHub Action workflow that compiles and
deploys the site automatically when the source is updated using [this GitHub workflow](https://github.com/hydephp/hydephp.com/blob/master/.github/workflows/build.yml).


--- creating-content/managing-assets.md ---


# Managing and Compiling Assets

## Introduction

Managing and compiling assets is a very common task in web development. Unfortunately, it's rarely fun.

With hyde, **you don't have to do it**, in fact, you can skip this entire page if you are happy with how it is.
But as always with Hyde, you can customize everything if you want to.

Hyde ships with a complete frontend using Blade views, TailwindCSS styles, and Alpine.js interactions.
Some extra custom styles are made in the HydeFront package, which is pre-installed and bundled in the pre-configured Laravel Mix.

To get you started quickly, all the styles are already compiled minified into `_media/app.css`, which will be copied
to the `_site/media/app.css` directory when you run `php hyde build`.


## Additional Information and Answers to Common Questions

### Is NodeJS/NPM Required for Using Hyde?

No, it is optional. All the compiled styles that you need are already installed, and NPM is only necessary if you want to compile your own styles.

### When Should Assets be Compiled?

The `_media/app.css` file that comes with Hyde contains TailwindCSS for all classes that are used in the default Blade views, as well as the HydeFront custom styles.
If you want to customize the Tailwind settings or add custom styles, you will need to recompile the styles yourself.

For example, if you customize the Blade views and add new classes or add new classes in Blade-based pages, you may need to compile the assets yourself to get the new styles.
If you use Markdown-based pages, you do not need to compile anything as those styles are already included in the compiled CSS file.


## How are assets stored and managed?

The frontend assets are separated into three places.

- The `resources/assets` contains **source** files, meaning files that will be compiled into something else.
Here you will find the `app.css` file that bootstraps the TailwindCSS styles. This file is also an excellent place
to add your custom styles. It is also where we import HydeFront. If you compile this file in the base install,
it will output the same file that's already included in Hyde.

- The `_media` folder contains **compiled** (and usually minified) files. When Hyde compiles your static site,
all asset files here will get copied as they are into the `_site/media` folder.

- The `_site/media` folder contains the files that are served to the user.

### What is the difference between `_media` and `_site/media`?

It may seem weird to have two folders for storing the compiled assets, but it is quite useful.

The `_site` directory is intended to be excluded from version control, while the `_media` folder is included in the
version control. You are of course free to modify this behavior by editing the `webpack.mix.js` file to change the output directory.


## How do I compile assets?

First, make sure that you have installed all the NodeJS dependencies using `npm install`.
Then run `npm run dev` to compile the assets. If you want to compile the assets for production, run `npm run prod`.
You can also run `npm run watch` to watch for changes in the source files and recompile the assets automatically.

### How does it work?

Hyde uses [Laravel Mix](https://laravel-mix.com/) (which is a wrapper for [webpack](https://webpack.js.org/)) to compile the assets.

When running the `npm run dev/prod` command, the following happens:

1. Laravel Mix will compile the `resources/assets/app.css` file into `_media/app.css` using PostCSS with TailwindCSS and AutoPrefixer.
2. Mix then copies the `_media` folder into `_site/media`, this is so that they are automatically accessible to your site without having to rerun `php hyde build`, making blend perfectly with the realtime compiler (`php hyde serve`).


## Telling Hyde where to find assets

### Customizing the Blade templates

To make it really easy to customize asset loading, the styles and scripts are loaded in dedicated Blade components.

- Styles are loaded in `hyde::layouts.styles`
- Scripts are loaded in `hyde::layouts.scripts`

To customize them, run the following command:

```bash
php hyde publish:views layouts
```

Then edit the files found in `resources/views/vendor/hyde/layouts` directory of your project.

### You might not even need to do anything!

For the absolute majority of the cases, you don't need to mess with these files. Hyde will automatically load the app.css file when it exists in the `_media` directory.

#### Loading from CDN

If you want to load the same pre-compiled file included with Hyde but from a CDN, you can set `load_app_styles_from_cdn` to `true` in the `config/hyde.php` file. While you lose the ability to customize it, your styles will be automatically updated when needed, as the installed Framework version will automatically specify the correct version to load.

### Using the TailwindCSS Play CDN

>warning Note that the Play CDN is not meant for production use, so enabling it will add a warning to the web console.

If you want to use the [TailwindCSS Play CDN](https://tailwindcss.com/docs/installation/play-cdn), all you need to do is
set `use_play_cdn` to `true` in the `config/hyde.php` file. This will in addition to loading the standard `app.css` file,
also add a script tag which loads the TailwindCSS Play CDN.

What's even better is that Hyde will also inject the contents of the included `tailwind.config.js` file into the script tag,
so the Play CDN styles match the ones created by Laravel Mix.

All in all, this allows you to tinker around with Tailwind without having to compile anything.


## Managing images

As mentioned above, assets stored in the _media folder are automatically copied to the _site/media folder,
making it the recommended place to store images. You can then easily reference them in your Markdown files.

### Referencing images

The recommended way to reference images are with relative paths as this offers the most compatibility,
allowing you to browse the site both locally on your filesystem and on the web when serving from a subdirectory.

>warning Note: The path is relative to the <b>compiled</b> file in the site output

The path to use depends on the location of the page. Note the subtle difference in the path prefix.

- If you are in a **Blog Post or Documentation Page**, use `../media/image.png`
- If in a **Markdown Page or Blade Page**, use `media/image.png`
- While not recommended, you can also use absolute paths: `/media/image.png`
- You can of course also use full URLs, for example when using a CDN.

#### Making images accessible

To improve accessibility, you should always add an `alt` text. Here is a full example for an image in a blog post:

```markdown
![Image Alt](../media/image.png "Image Title") # Note the relative path
```

### Setting a featured image for blog posts

Hyde offers great support for creating data-rich and accessible featured images for blog posts.

You can read more about this in the [creating blog posts page](blog-posts#image).


--- creating-content/documentation-pages.md ---

```


## Dynamic content generation

Hyde makes documentation pages easy to create by automatically generating dynamic content such as the sidebar and page title.
If you are not happy with the results you can customize them in the config or with front matter.

### Front Matter reference

Before we look at how to override things, here is an overview of the relevant content Hyde generates,
and where the data is from as well as where it can be overridden.

| Property                        | Description                                            | Dynamic Data Source                 | Override in          |
|---------------------------------|--------------------------------------------------------|-------------------------------------|----------------------|
| `title` (string)                | The title of the page used in the HTML `<title>` tag   | The first H1 heading (`# Foo`)      | Front matter         |
| `navigation.label` (string)     | The label for the page shown in the sidebar            | The page basename | Front matter, config |
| `navigation.priority` (integer) | The priority of the page used for ordering the sidebar | Defaults to 999                     | Front matter, config |
| `navigation.hidden` (boolean)   | Hides the page from the sidebar                        | _none_                              | Front matter, config |
| `navigation.group` (string)     | The group the page belongs to in the sidebar           | Subdirectory, if nested             | Front matter         |


## Sidebar

The sidebar is automatically generated from the files in the `_docs` directory. You will probably want to change the order
of these items. You can do this in two ways, either in the config or with front matter using the navigation array settings.

### Table of contents

Hyde automatically generates a table of contents for the page and adds it to the sidebar.

The behaviour of this can be changed in the configuration file.
See [the customization page](customization#navigation-menu--sidebar) for more details.

### Sidebar ordering

The sidebar is sorted/ordered by the `priority` property. The higher the priority the further down in the sidebar it will be.
The default priority is 999. You can override the priority using the following front matter:

```yaml
navigation:
    priority: 5
```

You can also change the order in the Docs configuration file.
See [the chapter in the customization page](customization#navigation-menu--sidebar) for more details. <br>
_I personally think the config route is easier as it gives an instant overview, however the first way is nice as well._

### Sidebar labels

The sidebar items are labeled with the `label` property. The default label is the filename of the file.
You can change it with the following front matter:

```yaml
navigation:
    label: "My Custom Sidebar Label"
```

### Sidebar grouping

Sidebar grouping allows you to group items in the sidebar into categories. This is useful for creating a sidebar with a lot of items.
The Hyde docs for instance use this.

The feature is enabled automatically when one or more of your documentation pages have the `navigation.group` property set
in the front matter. This will then switch to a slightly more compact sidebar layout with pages sorted into categories.
Any pages without the group front matter will get put in the "Other" group.

#### Using Front Matter

To enable sidebar grouping, you can add the following front matter to your documentation pages:

```yaml
navigation:
    group: "Getting Started"
```

#### Automatic subdirectory-based grouping

You can also automatically group your documentation pages by placing source files in sub-directories.

For example, putting a Markdown file in `_docs/getting-started/`, is equivalent to adding the same front matter seen above.

>info Note that when the [flattened output paths](#using-flattened-output-paths) setting is enabled (which it is by default), the file will still be compiled to the `_site/docs/` directory like it would be if you didn't use the subdirectories.

### Hiding items

You can hide items from the sidebar by adding the `hidden` property to the front matter:

```yaml
navigation:
    hidden: true
```

This can be useful to create redirects or other items that should not be shown in the sidebar.

>info The index page is by default not shown as a sidebar item, but instead is linked in the sidebar header. <br>


## Customization

Please see the [customization page](customization) for in-depth information on how to customize Hyde,
including the documentation pages. Here is a high level overview for quick reference though.

### Output directory

If you want to store the compiled documentation pages in a different directory than the default 'docs' directory,
for example to specify a version like the Hyde docs does, you can specify the output directory in the Hyde configuration file.
The path is relative to the site output, typically `_site`.

```php
// filepath: config/hyde.php
'output_directories' => [
    \Hyde\Pages\DocumentationPage::class => 'docs' // default [tl! --]
    \Hyde\Pages\DocumentationPage::class => 'docs/1.x' // What the Hyde docs use [tl! ++]
]
```

Note that you need to take care as to not set it to something that may conflict with other parts, such as media or posts directories.

### Automatic navigation menu

By default, a link to the documentation page is added to the navigation menu when an index.md file is found in the `_docs` directory. Please see [the customization page](customization#navigation-menu--sidebar) for more information.

### Sidebar header name

By default, the site title shown in the sidebar header is generated from the configured site name suffixed with "docs".
You can change this in the Docs configuration file. Tip: The header will link to the docs/index page, if it exists.

```php
'title' => 'API Documentation',
```

### Sidebar page order

To quickly arrange the order of items in the sidebar, you can reorder the page identifiers in the list and the links will be sorted in that order.
Link items without an entry here will have fall back to the default priority of 999, putting them last.

```php
'sidebar_order' => [
    'readme',
    'installation',
    'getting-started',
]
```

See [the chapter in the customization page](customization#navigation-menu--sidebar) for more details. <br>

### Table of contents settings

In the `config/docs.php` file you can configure the behavior, content, and the look and feel of the sidebar table of contents.
You can also disable the feature completely.

```php
'table_of_contents' => [
    'enabled' => true,
    'min_heading_level' => 2,
    'max_heading_level' => 4,
    'smooth_page_scrolling' => true,
],
```

### Using flattened output paths

If this setting is set to true, Hyde will output all documentation pages into the same configured documentation output directory.
This means that you can use the automatic directory based grouping feature, but still have a "flat" output structure.
Note that this means that you can't have two documentation pages with the same filename or navigation menu label as they will overwrite each other.

If you set this to false, Hyde will match the directory structure of the source files (just like all other pages).

```php
// Filepath: config/docs.php
'flattened_output_paths' => true,
```


## Search feature

### Introduction

The HydeSearch plugin adds a search feature to documentation pages. It consists of two parts, a search index generator
that runs during the build command, and a frontend JavaScript plugin that adds the actual search widget.

>info Tip: The HydeSearch plugin is what powers the search feature on this site! Why not [try it out](search)!

The search feature is enabled by default. You can disable it by removing the `documentationSearch` from the Hyde `Features` config array.

```php
// filepath: config/hyde.php
'features' => [
    Features::documentationSearch(), // [tl! --]
],
```

### Using the search

The search works by generating a JSON search index which the JavaScript plugin loads asynchronously.

Two ways to access the search are added, one is a full page search screen that will be saved to `docs/search.html`.

The second method is a button added to the documentation pages, similar to how Algolia DocSearch works.
Opening it will open a modal with an integrated search screen. You can also open the dialog using the keyboard shortcut `/`.

>info The full page can be disabled by setting `create_search_page` to `false` in the `docs` config.

### Hiding pages from indexing

If you have a large page on your documentation site, like a changelog, you may want to hide it from the search index.
You can do this by adding the page identifier to the `exclude_from_search` array in the `docs` config, similar to how
navigation menu items are hidden. The page will still be accessible as normal but will be added to the search index JSON file.

```php
// filepath: config/docs.php
'exclude_from_search' => [
  'changelog',
]
```

### Live search with the realtime compiler

The Realtime Compiler that powers the `php hyde serve` command will automatically generate a fresh search index each time the browser requests it.


## Automatic "Edit Page" button

### Introduction

Hyde can automatically add links to documentation pages that takes the user
to a GitHub page (or similar) to edit the page. This makes it great for open-source projects
looking to allow others to contribute to the documentation in a quick and easy manner.

The feature is automatically enabled when you specify a base URL in the Docs configuration file.
Hyde expects this to be a GitHub path, but it will probably work with other methods as well,
if not, please send a PR and/or create an issue on the [GitHub repository](https://github.com/hydephp/framework)!

>info Tip: This documentation site uses this feature, scroll down to the bottom of this page and try it out!

### Configuration

As an example configuration, let's take a practical example for how HydePHP.com uses this feature.

```php
// Filepath: config/docs.php

'source_file_location_base' => 'https://github.com/hydephp/docs/blob/master/',
```

#### Changing the button text

Changing the label is easy, just change the following config setting:

```php
// Filepath: config/docs.php
'edit_source_link_text' => 'Edit Source on GitHub',
```

#### Changing the position

By default, the button will be shown in both the documentation page footer.
You can change this by setting the following config setting to `'header'`, `'footer'`, or `'both'`

```php
// Filepath: config/docs.php
'edit_source_link_position' => 'header',
```

#### Adding a button icon

This is not included out of the box, but is easy to add with some CSS!
Just target the `.edit-page-link` class.

```css
// filepath e.g. app.css
.edit-page-link::before {content: "✏ "}
```

#### Changing the Blade view

You can also publish the `edit-source-button.blade.php` view and change it to your liking.


--- creating-content/blog-posts.md ---


## Write your Markdown here

Lorem ipsum dolor sit amet, consectetur adipisicing elit.
Autem aliquid alias explicabo consequatur similique,
animi distinctio earum ducimus minus, magnam.
```


## Supported Front Matter properties

### Post Front Matter Schema

Here is a quick reference of the supported front matter properties.
Keep on reading to see further explanations, details, and examples.

| **KEY NAME**   | **VALUE TYPE** | **EXAMPLE / FORMAT**             |
|----------------|----------------|----------------------------------|
| `title`        | string         | "My New Post"                    |
| `description`  | string         | "A short description"            |
| `category`     | string         | "my favorite recipes"            |
| `date`         | string         | "YYYY-MM-DD [HH:MM]"             |
| `author`       | string/array   | _See [author](#author) section_  |
| `image`        | string/array   | _See [image](#image) section_    |

Note that YAML here is pretty forgiving. In most cases you do not need to wrap strings in quotes,
but it can help in certain edge cases, for example if the text contains special Yaml characters, thus they are included here.

In the examples below, when there are multiple examples, they signify various ways to use the same property.

When specifying an array you don't need all the sub-properties. The examples generally show all the supported values.

### Title

```yaml
title: "My New Post"
```

### Description

```yaml
description: "A short description used in previews and SEO"
```

### Category

```yaml
category: blog
```

```yaml
category: "My favorite recipes"
```

### Date

```yaml
date: "2022-01-01"
```

```yaml
date: "2022-01-01 12:00"
```

### Author

Specify a page author, either by a username for an author defined in the `authors` config, or by an arbitrary name,
or by an array of author data. See the [Post Author](#post-authors) section for more details.

#### Arbitrary name displayed "as is"

```yaml
author: "Mr. Hyde"
```

#### Username defined in `authors` config

```yaml
author: mr_hyde
```

#### Array of author data

```yaml
author:
    name: "Mr. Hyde"
    username: mr_hyde
    website: https://twitter.com/HydeFramework
```

When specifying an array you don't need all the sub-properties. The example just shows all the supported values.
Array values here will override all the values in the `authors` config entry.

### Image

Specify a cover image for the post, either by a local image path for a file in the `_media/` directory, or by a full URL.
Any array data is constructed into a dynamic fluent caption, and injected into post and page metadata.

#### Local image path

When supplying an image source with a local image path, the image is expected to be stored in the `_media/` directory.
Like all other media files, it will be copied to `_site/media/` when the site is built, so Hyde will resolve links accordingly.

```yaml
image: image.jpg
```

#### Full URL

Full URL starting with `http(s)://`) or `//` (protocol-relative).
The image source will be used as-is, and no additional processing is done.

```yaml
image: https://cdn.example.com/image.jpg
```

#### Data-rich image

You can also supply an array of data to construct a rich image with a fluent caption.

```yaml
image:
    source: Local image path or full URL
    altText: "Alt text for image"
    titleText: "Tooltip title"
    copyright: "Copyright (c) 2022"
    licenseName: "CC-BY-SA-4.0"
    licenseUrl: https://example.com/license/
    authorUrl: https://photographer.example.com/
    authorName: "John Doe"
```

> See [posts/introducing-images](https://hydephp.com/posts/introducing-images)
> for a detailed blog post with examples and schema information!
{ .info }


## Using images in posts

To use images stored in the `_media/` directory, you can use the following syntax:

```markdown
![Image Alt](../media/image.png "Image Title")
```

_Note the relative path since the blog post is compiled to `posts/example.html`_

To learn more, check out the [chapter in managing assets](managing-assets#managing-images)


--- creating-content/static-pages.md ---


# Page Title

// Write your content here
```

You can of course also create the file yourself with your text editor.

### Front Matter is optional

The most common front matter used for Markdown pages is the title, which is used as the HTML `<title>`.

If you don't supply a front matter title, Hyde will attempt to find a title in the Markdown body by searching
for the first level one heading (`# Page Title`), and if that fails, it will generate one from the filename.

#### Navigation Front Matter

Furthermore, you can customize how the page appears in the navigation menu using the following front matter options.
You can set just one or all of them, as Hyde will fill in the gaps for the rest.

```yaml
navigation:
    label: 'string',
    priority: 'int',
    hidden: 'bool',
    group: 'string',
```

- `label` is the text that will be displayed in the navigation menu
- `priority` is the order in which the page will appear in the navigation menu (`order` is also supported)
- `hidden` will hide the page from the navigation menu (`visible`) is also supported, but obviously invert the value)
- `group` will put the page in a dropdown menu with the specified group name (`category`) is also supported)


## Creating Blade Pages

Since Hyde is based on Laravel and uses the powerful Blade templating engine, you can use Blade pages to create more
complex pages with both standard HTML, PHP code, and the templating opportunities provided by Blade directives.

If you are not familiar with Blade, you may want to read [the Laravel Blade docs](https://laravel.com/docs/10.x/blade) first.

### Scaffolding Blade Pages

We can scaffold Blade pages using the same CLI command as Markdown pages, however, this time we need to specify that
we want to use the `blade` page type, by using the `--type` option.

```bash
php hyde make:page "Page Title" --type="blade"
```

This will create a file saved as `_pages/page-title.blade.php`

You can of course also create the file yourself with your text editor, however,
the scaffolding command for Blade pages is arguably even more helpful than the
one for Markdown pages, as this one automatically adds the included app Layout.

Let's take a look at the scaffolded file. You can also copy and paste this
if you don't want to use the scaffolding command.

```blade
@extends('hyde::layouts.app')
@section('content')
@php($title = "Page Title")

<main class="mx-auto max-w-7xl py-16 px-8">
    <h1 class="text-center text-3xl font-bold">Page Title</h1>
</main>

@endsection
```

> Tip: You don't have to use Blade in Blade pages. It's also perfectly fine to use plain HTML,
> however you still need to use the `blade.php` extension so Hyde can recognize it.


## When to use which?

Markdown pages look great and work well for simple "about" pages and the like, but with Markdown we are still pretty limited.

If you are comfortable with it, and have the need for it, use Blade to create more complex pages! And mix and match between them! Some page types are better suited for Markdown, and others for Blade.

### Comparison

| Markdown                                            | Blade                                                                               |
|-----------------------------------------------------|-------------------------------------------------------------------------------------|
| ➕ Easily created and updated                        | ➕ Full control over the HTML                                                        |
| ➕ Very fast to create simple and lightweight pages  | ➕ Use the default app layout or create your own                                     |
| ➕ Suited for content heavy pages such as "about us" | ➕ Use Blade templates and components to keep code DRY                               |
| ➖ Not as flexible as Blade pages                    | ➕ Use arbitrary PHP right in the page to create dynamic content                     |
|                                                     | ➕ Access to all Blade helper directives like @foreach, @if, etc.                    |
|                                                     | ➖ Takes longer to create as as you need to write the markup                         |
|                                                     | ➖ You may need to [recompile your CSS](managing-assets) if you add Tailwind classes |

### Live Demos

The Hyde website ([hydephp.com](https://hydephp.com/)) uses both Markdown and Blade pages. The homepage for example, is a Blade page and uses a bunch of custom HTML.

A great example of a Markdown page can be found at [hydephp.github.io/portfolio-demo](https://hydephp.github.io/portfolio-demo), you can see the [page source here on GitHub](https://github.com/hydephp/portfolio-demo/blob/master/_pages/index.md).


## Bonus: Creating HTML Pages

If you have an already created `HTML` page, simply drop it into the `_pages` directory and Hyde will copy it over as it is
into the `_site` directory. Like all other Hyde pages, the page will show up in the navigation menu using a title parsed from the filename.
You won't be able to change any settings with front matter, however.


--- README.md ---


# Hyde Documentation

This is the source for the HydePHP Documentation. Updates here are automatically propagated to the [HydePHP.com](https://github.com/hydephp/hydephp.com) website.

This document is not propagated to the website. It is only for the GitHub development repository.


--- getting-started/console-commands.md ---


# Console Commands

The primary way of interacting with Hyde is through the command line using the HydeCLI.

If you have ever used the Artisan Console in Laravel you will feel right at home,
the HydeCLI is based on Artisan after all!


## Introduction

To use the HydeCLI, run `php hyde` from your project directory followed by a command.

All HydeCLI commands start with `php hyde`. Anything in `[brackets]` is optional.
If an argument or option value has a space in it, it needs to be wrapped in quotes.

The HydeCLI exists at the root of your application as the `hyde` script and provides a number of helpful commands that can
assist you while you build your site. To view a list of all available Hyde commands, you may use the list command:

```bash
// torchlight! {"lineNumbers": false}
php hyde list
```

### Got stuck? The CLI can help.

Every command also includes a "help" screen which displays and describes the command's available arguments and options.
To view a help screen, precede the name of the command with `help`:

```bash
// torchlight! {"lineNumbers": false}
php hyde help <command>
```

You can also always add `--help` to a command to show detailed usage information.

```bash
// torchlight! {"lineNumbers": false}
php hyde <command> --help
```


## Available Commands

Here is a quick reference of all the available commands. You can also run `php hyde list` to see this list.

| Command                                 | Description                                                                                 |
|-----------------------------------------|---------------------------------------------------------------------------------------------|
| [`build`](#build)                       | Build the static site                                                                       |
| [`serve`](#serve)                       | Start the realtime compiler server                                                          |
| [`rebuild`](#rebuild)                   | Run the static site builder for a single file                                               |
| [`build:rss`](#build-rss)               | Generate the RSS feed                                                                       |
| [`build:search`](#build-search)         | Generate the `docs/search.json` file                                                        |
| [`build:sitemap`](#build-sitemap)       | Generate the `sitemap.xml` file                                                             |
| [`make:page`](#make-page)               | Scaffold a new Markdown, Blade, or documentation page file                                  |
| [`make:post`](#make-post)               | Scaffold a new Markdown blog post file                                                      |
| [`publish:configs`](#publish-configs)   | Publish the default configuration files                                                     |
| [`publish:homepage`](#publish-homepage) | Publish one of the default homepages as `index.blade.php`                                   |
| [`publish:views`](#publish-views)       | Publish the hyde components for customization. Note that existing files will be overwritten |
| [`vendor:publish`](#vendor-publish)     | Publish any publishable assets from vendor packages                                         |
| [`route:list`](#route-list)             | Display all registered routes                                                               |
| [`validate`](#validate)                 | Run a series of tests to validate your setup and help you optimize your site                |
| [`list`](#available-commands)           | List all available commands                                                                 |


## Build the static site

<a name="build" style="display: inline-block; position: absolute; margin-top: -5rem;"></a>

```bash
// torchlight! {"lineNumbers": false}
php hyde build [--run-dev] [--run-prod] [--run-prettier] [--pretty-urls] [--no-api]
```

Build the static site

#### Options

|                  |                                            |
|------------------|--------------------------------------------|
| `--run-dev`      | Run the NPM dev script after build         |
| `--run-prod`     | Run the NPM prod script after build        |
| `--run-prettier` | Format the output using NPM Prettier       |
| `--pretty-urls`  | Should links in output use pretty URLs?    |
| `--no-api`       | Disable API calls, for example, Torchlight |


## Run the static site builder for a single file

<a name="rebuild" style="display: inline-block; position: absolute; margin-top: -5rem;"></a>

```bash
// torchlight! {"lineNumbers": false}
php hyde rebuild <path>
```

Run the static site builder for a single file

#### Arguments

|        |                                                                                |
|--------|--------------------------------------------------------------------------------|
| `path` | The relative file path (example: \_posts/hello-world.md) \n - Is required: yes |


## Start the realtime compiler server

<a name="serve" style="display: inline-block; position: absolute; margin-top: -5rem;"></a>

```bash
// torchlight! {"lineNumbers": false}
php hyde serve [--host [HOST]] [--port [PORT]]
```

Start the realtime compiler server.

#### Options

|           |                        |
|-----------|------------------------|
| `--host=` | [default: "localhost"] |
| `--port=` | [default: 8080]        |


## Test and validate your project to optimize your site

<a name="validate" style="display: inline-block; position: absolute; margin-top: -5rem;"></a>

```bash
// torchlight! {"lineNumbers": false}
php hyde validate
```

Run a series of tests to validate your setup and help you optimize your site.


## Generate the RSS feed

<a name="build-rss" style="display: inline-block; position: absolute; margin-top: -5rem;"></a>

```bash
// torchlight! {"lineNumbers": false}
php hyde build:rss
```

Generate the RSS feed


## Generate the `docs/search.json` file

<a name="build-search" style="display: inline-block; position: absolute; margin-top: -5rem;"></a>

```bash
// torchlight! {"lineNumbers": false}
php hyde build:search
```

Generate the `docs/search.json` file


## Generate the `sitemap.xml` file

<a name="build-sitemap" style="display: inline-block; position: absolute; margin-top: -5rem;"></a>

```bash
// torchlight! {"lineNumbers": false}
php hyde build:sitemap
```

Generate the `sitemap.xml` file


## Scaffold a new Markdown, Blade, or documentation page file

<a name="make-page" style="display: inline-block; position: absolute; margin-top: -5rem;"></a>

```bash
// torchlight! {"lineNumbers": false}
php hyde make:page [--type [TYPE]] [--blade] [--docs] [--force] [--] [<title>]
```

Scaffold a new Markdown, Blade, or documentation page file

#### Arguments & Options

|                   |                                                                            |
|-------------------|----------------------------------------------------------------------------|
| `title`           | The name of the page file to create. Will be used to generate the filename |
| `--type=markdown` | The type of page to create (markdown, blade, or docs)                      |
| `--blade`         | Create a Blade page                                                        |
| `--docs`          | Create a Documentation page                                                |
| `--force`         | Overwrite any existing files                                               |


## Scaffold a new Markdown blog post file

<a name="make-post" style="display: inline-block; position: absolute; margin-top: -5rem;"></a>

```bash
// torchlight! {"lineNumbers": false}
php hyde make:post [--force] [--] [<title>]
```

Scaffold a new Markdown blog post file

#### Arguments & Options

|           |                                                                            |
|-----------|----------------------------------------------------------------------------|
| `title`   | The title for the Post. Will also be used to generate the filename         |
| `--force` | Should the generated file overwrite existing posts with the same filename? |


## Publish the default configuration files

<a name="publish-configs" style="display: inline-block; position: absolute; margin-top: -5rem;"></a>

```bash
// torchlight! {"lineNumbers": false}
php hyde publish:configs
```

Publish the default configuration files


## Publish one of the default homepages as `index.blade.php`.

<a name="publish-homepage" style="display: inline-block; position: absolute; margin-top: -5rem;"></a>

```bash
// torchlight! {"lineNumbers": false}
php hyde publish:homepage [--force] [--] [<homepage>]
```

Publish one of the default homepages as `index.blade.php`.

#### Arguments & Options

|            |                                 |
|------------|---------------------------------|
| `homepage` | The name of the page to publish |
| `--force`  | Overwrite any existing files    |


## Publish the hyde components for customization

<a name="publish-views" style="display: inline-block; position: absolute; margin-top: -5rem;"></a>

```bash
// torchlight! {"lineNumbers": false}
php hyde publish:views [<category>]
```

Publish the hyde components for customization. Note that existing files will be overwritten.

#### Arguments

|            |                         |
|------------|-------------------------|
| `category` | The category to publish |


## Display all registered routes.

<a name="route-list" style="display: inline-block; position: absolute; margin-top: -5rem;"></a>

```bash
// torchlight! {"lineNumbers": false}
php hyde route:list
```

Display all registered routes.


## Publish any publishable assets from vendor packages

<a name="vendor-publish" style="display: inline-block; position: absolute; margin-top: -5rem;"></a>

```bash
// torchlight! {"lineNumbers": false}
php hyde vendor:publish [--existing] [--force] [--all] [--provider [PROVIDER]] [--tag [TAG]]
```

Publish any publishable assets from vendor packages

#### Options

|               |                                                                            |
|---------------|----------------------------------------------------------------------------|
| `--existing`  | Publish and overwrite only the files that have already been published      |
| `--force`     | Overwrite any existing files                                               |
| `--all`       | Publish assets for all service providers without prompt                    |
| `--provider=` | The service provider that has assets you want to publish                   |
| `--tag=`      | One or many tags that have assets you want to publish \n- Is multiple: yes |


--- getting-started/front-matter.md ---


## Markdown comes here

Lorem ipsum dolor sit amet, etc.
```

### Front Matter in Blade

HydePHP has experimental support for creating front-matter in Blade templates, called BladeMatter.

The actual syntax does not use YAML; but instead PHP. However, the parsed end result is the same. Please note that
BladeMatter currently does not support multidimensional arrays or multi-line directives as the data is statically parsed.

To create BladeMatter, you simply use the default Laravel Blade `@php` directive to declare a variable in the template.

```blade
@php($title = 'BladeMatter Demo')
```

It will then be available through the global `$page` variable, `$page->matter('title')`.
Hyde will of course also use the data for contextual autoconfiguration in the same way it would with Markdown and use the value as the page title.

Another idea is to use `@php($navigation = ['hidden' => true])` if you want to hide a page from the navigation. The opportunities are limitless!


--- getting-started/quickstart.md ---


# Quickstart Guide

## Installing HydePHP using Composer

The recommended method of installing Hyde is using Composer, which installs the required dependencies on a per-project basis.

```bash
// torchlight! {"lineNumbers": false}
composer create-project hyde/hyde
```

### Requirements

Hyde is based on [Laravel 10](https://laravel.com/docs/10.x/releases)
which requires a minimum PHP version of 8.1.
You should also have [Composer](https://getcomposer.org/) installed.

To use some features like [compiling your own assets](managing-assets)
you also need NodeJS and NPM.


## Using the Hyde CLI

The main way to interact with Hyde is through the [HydeCLI](console-commands), a Laravel Artisan-based command-line interface. Learn more about the HydeCLI in the [console commands](console-commands) documentation.


## Starting a development server

To make previewing your site a breeze you can use the realtime compiler, which builds your pages on the fly.

```bash
php hyde serve
```
Simply run the serve command, and you will be able to preview your site at [http://localhost:8080](http://localhost:8080).


## Creating content

### Directory structure

Creating content with Hyde is easy! Simply place source files in one of the source directories,
and Hyde will automatically discover, parse, and compile them to static HTML.
The directory and file extension of a source file will determine how HydePHP parses and compiles it.
Please see the [directory structure](core-concepts#directory-structure) section for more information.

### Scaffolding files

You can scaffold blog post files using the `php hyde make:post` command which automatically creates the front matter, based on your input selections.
You can also scaffold pages with the `php hyde make:page` command.

```bash
php hyde make:post
php hyde make:page
```

### Compiling to static HTML

Now that you have some amazing content, you'll want to compile your site into static HTML. Thankfully, this is as easy as executing the `build` command, after which your compiled site is stored in the `_site` directory.

```bash
php hyde build
```

When building the site, Hyde will scan your source directories for files and compile them into static HTML using the appropriate layout depending
on what kind of page it is. You don't have to worry about routing as Hyde takes care of everything, including creating navigation menus!

### Managing assets

Hyde comes bundled with a precompiled and minified `app.css` file, containing all the Tailwind you need for the default views meaning that you don't even need to use NPM. However, Hyde is already configured to use Laravel Mix to compile your assets if you feel like there's a need to build the assets yourself. See more on the [Managing Assets](managing-assets) page.

### Deploying your site

You are now ready to show your site to the world! Simply copy the `_site` directory to your web server's document root, and you're ready to go.

You can even use GitHub Pages to host your site for free. That's what the Hyde website does, using an Actions CI workflow that automatically builds and deploys this site.


## Further reading

Here's some ideas of what to read next:

- [Architecture Concepts & Directory Structure](core-concepts)
- [Console Commands with the HydeCLI](console-commands)
- [Creating Blog Posts](blog-posts)


--- getting-started/core-concepts.md ---


## Markdown comes here

Lorem ipsum dolor sit amet, etc.
```

### Front Matter in Blade

HydePHP has experimental support for creating front-matter in Blade templates, called [BladeMatter](front-matter#front-matter-in-blade),
where code in `@php` directives are statically parsed into page object's front matter data where it can be accessed in your templates.

```blade
@php($title = 'BladeMatter Demo') // Equivalent to `title: 'BladeMatter Demo'` in Yaml
```


## Automatic Routing

>info **In a nutshell:** Hyde will automatically create routes for your source files.

If you've ever worked in an MVC framework, you are probably familiar with the concept of routing.
And you are probably also familiar with how boring and tedious it can be. Thankfully, Hyde takes the pain out of routing by doing it for you!

During the Autodiscovery process. Hyde will automatically discover all the content files in the source directories,
and create routes for all of them, and store them in an index which works as a two-way link between source files and compiled files.

You can see all the routes and their corresponding source files by running the `hyde route:list` command.

```bash
php hyde route:list
```

To access routes in your code, simply use the Routes facade and specify the route key for the desired page.

```php
Routes::get('posts/my-post')
```

To learn more about the routing system, please visit the [routing documentation](automatic-routing).


## Global Page Data

During the build of each page, Hyde will inject some data available to all Blade views. If you are not planning to write
any custom Blade templates, you can safely ignore this section. If you are, here are the three global variables you can use:

- `$page`: The [Page Object](#page-models) for the current page.
- `$route`: The [Route Object](#automatic-routing) for the current page.
- `$routeKey`: The [Route Key](#paths-identifiers-and-route-keys) for the current page.

The `$page` variable is likely to the most important one, as it contains all the data for the current page.
Depending on the page type, you will have different helpers available. But `$page->matter()` is likely to be very helpful.

You can see all the helpers in the [Page API](hyde-pages) reference page.


## Terminology

In this quick reference, we'll briefly go over some terminology and concepts used in HydePHP.
This will help you understand the documentation and codebase better, as well as helping you know what to search for when you need help.

### Table of contents

<div class="lg:flex">

<div style="margin-right: 2rem;">

#### Tools

- [HydePHP](#hydephp)
- [Laravel](#laravel)
- [Composer](#composer)
- [Tailwind CSS](#tailwind-css)

</div>

<div style="margin-right: 2rem;">

#### Languages

- [Front Matter](#front-matter)
- [Markdown](#markdown)
- [Blade](#blade)
- [YAML](#yaml)
- [PHP](#php)
- [HTML](#html)

</div>

<div style="margin-right: 2rem;">

#### General Concepts

- [Static Sites](#static-sites)
- [Version Control](#version-control)
- [Git](#git)

</div>

<div style="margin-right: 2rem;">

#### HydePHP Features

- [Autodiscovery](#autodiscovery)
- [Page Types](#page-types)
- [Page Identifiers](#page-identifiers)
- [Routes](#routes)
- [Route Keys](#route-keys)

</div>

</div>

[//]: # (Languages and Tools)

### HydePHP

HydePHP is a static site generator written in PHP, designed to make it easy for developers to build fast and secure websites.
It uses a simple directory structure and templating system to generate static websites from content files,
and can be easily extended using PHP libraries and packages.

### Laravel

Laravel is the PHP framework that HydePHP is built on top of. We use a specialized version called Laravel Zero,
which is optimized for command-line applications.

### Front Matter

Front Matter is a block of YAML, stored at the top of a Markdown file, enclosed by a set of triple-dashed lines.
It is commonly used to store metadata about the content, such as the title, author, date, etc.

### Markdown

Markdown is a lightweight markup language that uses plain text formatting syntax, designed to make it easy to create
structured content for the web. HydePHP uses Markdown as the base for most of its content files.

### Blade

Blade is the templating engine from Laravel, which allows developers to write clean and reusable code for the
presentation layer of web applications. HydePHP uses Blade both for the built-in views and components,
as well as to provide powerful templating capabilities through Blade-based pages.

### YAML

YAML is a human-readable data serialization format used for configuration files and often used as the syntax for
Front Matter in HydePHP content files. YAML is designed to be easily read by humans and parsed by machines,
making it a popular choice for many applications and frameworks.

### PHP

PHP is a popular server-side scripting language used for web development that can be embedded in HTML.
HydePHP is built on top of PHP and utilizes its powerful capabilities for generating static websites.

### HTML

HTML (Hypertext Markup Language) is the standard markup language used to create web pages and web applications.
HydePHP uses HTML to render the static websites generated from its content files and templates.

### Tailwind CSS

Tailwind CSS is a utility-first CSS framework used for rapidly building custom user interfaces.
HydePHP supports Tailwind CSS out of the box through the built-in Blade templates,
making it easy for developers to create beautiful and responsive websites without writing custom CSS.

### Composer

Composer is a dependency manager for PHP that simplifies the process of installing and managing packages required by
PHP applications. HydePHP uses Composer to manage its own dependencies and make it easy for users to install and use the software.

### Static Sites

A static website is a collection of HTML web pages that are delivered to the user's web browser exactly as they are stored
on the web server. HydePHP generates static websites, making them fast, secure, and easy to deploy.

### Version Control

HydePHP can be easily integrated with Git to manage website source files and track changes over time,
as one of the many benefits with static sites is that they are designed to be version controlled.

### Git

Git is a free and open-source distributed version control system that is widely used for software development.
Git repositories can be hosted on GitHub, GitLab, BitBucket, or any other Git hosting service.

[//]: # (HydePHP Features)

### Autodiscovery

Content files, including Markdown and Blade files, are automatically discovered and compiled to HTML during site builds.
During autodiscovery, Hyde also generates dynamic data to enrich your content based on the page type.

In short the autodiscovery is split into three steps:
`File discovery -> Page parsing -> Route generation`

### Page Types

All pages in HydePHP are internally represented by a page object that extends the HydePage class. Each page type has its
own page class which acts as a blueprint defining information for the framework to parse a file and generate relevant data.

### Page Identifiers

The page identifier is the name of the file without the file extension, relative to the page type's source directory.
The identifier is used to generate the route key, which is used to generate the file name for the compiled HTML file.

### Routes

All pages are internally bound to a Route object, through the route key. During the build process, each route is
compiled to HTML using the page object's data, and saved to the output directory with a file name created from the route key.
Since routes are generated automatically during autodiscovery, there is no need to create them manually.

### Route Keys

The route key is the URL path relative to the site webroot, without the file extension. The route key is the common
identifier binding Page objects to Route objects, and is used to generate the file name for the compiled HTML file.

Route keys generation can be visualised as follows: `<PageClass::OutputDirectory>/<PageIdentifier>`


--- index.md ---

# Elegant and Powerful Static Site Generator

<style>.images-inline img { display: inline; margin: 4px 2px;}</style>

[![Latest Version on Packagist](https://img.shields.io/packagist/v/hyde/framework?include_prereleases)](https://packagist.org/packages/hyde/framework)
[![Total Downloads on Packagist](https://img.shields.io/packagist/dt/hyde/framework)](https://packagist.org/packages/hyde/framework)
[![Test Coverage](https://codecov.io/gh/hydephp/develop/branch/master/graph/badge.svg?token=G6N2161TOT)](https://codecov.io/gh/hydephp/develop)
[![Scrutinizer Code Quality](https://scrutinizer-ci.com/g/hydephp/develop/badges/quality-score.png?b=master)](https://scrutinizer-ci.com/g/hydephp/develop/?branch=master)
[![Psalm Type Coverage](https://shepherd.dev/github/hydephp/develop/coverage.svg)](https://shepherd.dev/github/hydephp/develop)
![License MIT](https://img.shields.io/github/license/hydephp/hyde)
{.images-inline .not-prose}


## About HydePHP

HydePHP is a new Static Site Builder focused on writing content, not markup. With Hyde, it is easy to create static
websites, blogs, and documentation pages using Markdown and (optionally) Laravel's Blade.

Operated entirely through the command-line, HydePHP provides developers with a fast and efficient way to create high-quality websites with ease.
Unlike traditional web development frameworks, sites compiled with HydePHP don't require any server to run,
making it an ideal choice for building lightweight and fast-loading websites.

Compared with other static site builders, Hyde is blazingly fast and seriously simple to get started with, yet it has the
full power of Laravel waiting for you when you need it, as Hyde is powered by Laravel Zero, a stripped-down version of
the robust and popular Laravel Framework, optimized for console applications.

Hyde makes creating websites easy and fun by taking care of the boring stuff, like routing, writing boilerplate, and
endless configuration. Instead, when you create a new Hyde project, everything you need to get started is already there
-- including precompiled TailwindCSS, well-crafted Blade templates, and easy-to-use asset management.

Hyde was inspired by JekyllRB and is designed for developers who are comfortable writing posts in Markdown, and it requires
virtually no configuration out of the box as it favours convention over configuration and is preconfigured with sensible defaults.


## Installation

HydePHP is a command-line interface (CLI) application that is installed on a per-project basis.

To use HydePHP, your system must have PHP version 8.1 or later installed, along with Composer, and access to a terminal.

The recommended method of installation is using Composer.

```bash
composer create-project hyde/hyde
```

Once installed, you can access the HydeCLI from the project root using the `hyde` command.

```bash
php hyde info
```


## Usage

Creating static websites with HydePHP is incredibly easy. First you need some content. You can just drop Markdown files
in any of the source directories, or let Hyde scaffold the files for you using one of the many commands.

```bash
php hyde make:post "My First Post"
php hyde make:page "About Me"
```

Once you have some content, you can run the build command to compile the content into beautiful static HTML.

```bash
php hyde build
```

And that's it, your amazing website is ready to be shared with the world!

### To learn more, head over to the [quickstart page](quickstart).


--- architecture-concepts/dynamic-data-discovery.md ---

# Dynamic Data Discovery

[//]: # (Adds a pseudo-subtitle)
<h3 style="margin-top: 0px; margin-bottom: 20px;"><i>AKA: Front Matter & Filling in the Gaps</i></h3>


## Introduction

Hyde wants to allow developers to write less, and do more. This is also a major difference between HydePHP and JekyllRB.
Jekyll will only do what you _tell it to do_. Hyde, on the other hand, will try to do what you _want it to do_.

As with all other chapters in this category, you don't need to know about this to use Hyde -- that's the whole point!
However, if you're anything like me, you'll likely find this interesting to read about, even if you don't really need to know it.

Hyde makes great use of front matter in both Markdown and Blade files (it's true!). However, it can quickly get tedious
and quite frankly plain boring to have to write a bunch of front matter all the time. As Hyde wants you to focus on
your content, and not your markup, front matter is optional and Hyde will try to fill in the gaps for you.

If you're not happy with Hyde's generated data you can always override it by adding front matter to your files.


## How it Works

Now, to the fun part: getting into the nitty-gritty details of how Hyde does this!

To make things simple the dynamic data is created in a special stage where the page object is being created.
If you have not yet read the [page models chapter](page-models) you might want to do so now.
You might also want to read about the [autodiscovery lifecycle](autodiscovery) for some context as to when this happens.

### The factory pipeline, in short

After basic information about the page has been gathered, such as the source file information and the front matter,
the page model is run through a series of factories. These are just classes that work around the limited data
that is available at this point, and will assign the rich data needed to make your Hyde page awesome.

There are a few factory classes. The one we will be looking at here is the `HydePageDataFactory` class, which is
responsible for data applicable to all page models. Complex structures and data only relevant to some page types
have their own factories, making the code more modular and maintainable.


## In-depth overview of a page factory

Let's take a look at how Hyde will discover the title of a page as an example. Since this is something used by all pages,
this discovery is done in the `HydePageDataFactory` class.

### Factory data input

The factory gets one input, a `CoreDataObject` class. Think of this like a DTO (Data Transfer Object) that holds
immutable data known from the start of the page construction process. It also has all the information needed
to identify the page and its source file. Here's a simplified version of the class:

```php
class CoreDataObject
{
    public readonly FrontMatter $matter;
    public readonly Markdown|false $markdown;

    public readonly string $pageClass;
    public readonly string $identifier;
    public readonly string $sourcePath;
    public readonly string $outputPath;
    public readonly string $routeKey;
}
```

### Processing the known data

Now that we have the input we pass it to the factory, where a simple algorithm is used to find the best title for the page.

```php
private function findTitleForPage(): string
{
    return $this->matter('title')
        ?? $this->findTitleFromMarkdownHeadings()
        ?? Hyde::makeTitle(basename($this->identifier));
}
```

As you can see, we are using the null coalescing operator (`??`) to return the first non-null value. We always want the
user to be able to set any data explicitly, so we first check the front matter in all factory methods.

If no title is set in the matter the method will return null, and Hyde will try the next step which is to search the headings.
If that fails, the last step will generate a title from the file name. This ensures that no matter what, we always have a title.

### Injecting the data into the page

Once the data has been discovered, it is injected into the page object. This is rather unglamorous but is mentioned
here for completeness. It's pretty simple. The factory will always return an array of the computed data, where the keys
always match the property names on the page object, so we just need to loop over the array and set the properties.

```php
foreach ($data->toArray() as $key => $value) {
    $this->{$key} = $value;
}
```

And that's pretty much it! Hyde will do this for all the data it can discover, all so that you can focus on your content.


--- architecture-concepts/extensions-api.md ---


# The Extensions API

## Introduction

The Extensions API a powerful interface designed for package developers who want to extend the functionality of HydePHP.

Using the API, you can hook directly into the HydePHP Kernel and extend sites with custom page types and new features.

This documentation page functions heavily through examples, so it's recommended that the sections are read in order.

### Prerequisites

Before creating your extension, it will certainly be helpful if you first become familiar with
the basic internal architecture of HydePHP, as well as how the auto-discovery system works,
so you can understand how your code works with the internals.

- [Core concepts overview](core-concepts)
- [Architecture concepts](architecture-concepts)
- [Autodiscovery](autodiscovery)

### The why and how of the Extensions API

HydePHP being a static site generator, the Extensions API is centered around [Page Models](page-models),
which you are hopefully already familiar with, otherwise you should read up on them first.

What the Extensions API does is to allow you to create custom page types, and tell HydePHP how to discover them.
This may sound like a small thing, but it's actually incredibly powerful as the page models are the foundation
of HydePHP's functionality. They tell the system how to discover pages, how to render them,
and how they interact with the site.

Any other functionality you want to add to HydePHP, such as new commands or configuration options,
can be added the same way as you would in Laravel, and are thus not part of our API.
See the [Laravel package development guide](https://laravel.com/docs/10.x/packages) for more.


## Creating your Extension class

The entry-point for your extension is your Extensions class. Within this, you can register the custom page classes.
If needed, you can also register discovery handlers which can run custom logic at various parts of the boot process.

In this article we will create an extension that registers a new type of page, a `JsonPageExtension`.

The first step is to create a class that extends the `HydeExtension` class:

```php
use Hyde\Foundation\Concerns\HydeExtension;

class JsonPageExtension extends HydeExtension {
    //
}
```

In here, we will register our extension class name in the `getPageClasses` method:

```php
class JsonPageExtension extends HydeExtension {
    public static function getPageClasses(): array {
        return [
            JsonPage::class,
        ];
    }
}
```

Hyde will then use the information from the `JsonPage` class to automatically discover the pages when booting the Kernel.
For example, if you specify the file extension and source directory, that is all Hyde needs to know to discover the pages.

If our pages need more complex discovery logic, we can create custom handlers. so let's take a quick look at that next.

### Discovery handlers

The discovery handlers lets you run code at various points of the booting process. This is usually only needed if your
page models cannot provide the information required for Hyde run the standard auto-discovery, and thus need custom logic.

Usually in these cases, you would only need to add files to the Kernel `FileCollection`,
though the `HydeExtension` class offers following three discovery handlers, in case you need them:

```php
/** Runs during file discovery */
public function discoverFiles(FileCollection $collection): void;

/** Runs during page discovery */
public function discoverPages(PageCollection $collection): void;

/** Runs during route discovery */
public function discoverRoutes(RouteCollection $collection): void;
```

Any of these can be implemented in your extension class, and they will be called during the discovery. As you can see,
the instance of the discovery collection is injected into the method for you to interact with.

#### Discovery handler example

Let's go crazy and implement a discovery handler to collect `JsonPage` files from an external API! We will do this
by implementing the `discoverPages` method in our extension class, and from there inject pages retrieved from our API.

```php
class JsonPageExtension extends HydeExtension {
    public function discoverPages(PageCollection $collection): void {
        $pages = Http::get('https://example.com/my-api')->collect();

        $pages->each(function (array $page) use ($collection): void {
            $collection->addPage(JsonPage::fromArray($page));
        });
    }
}
```

Since the discovery steps are handled sequentially, the added pages will automatically be discovered as routes without
us having to implement that handler method. As we inject the page objects directly, we bypass the need of the `FileCollection`.


## Registering your extension

Now that we have our extension class, we need to register it with HydePHP.

It's important that your class is registered before the HydeKernel boots. Therefore, an excellent place for this is the
`register` method of your extensions service provider,  where you call the `registerExtension` method of the `HydeKernel`
singleton instance, which you can access via the `Hyde\Hyde` facade, or via the service container.

```php
use Hyde\Hyde;
use Hyde\Foundation\HydeKernel;
use Illuminate\Support\ServiceProvider;

class JsonPageExtensionServiceProvider extends ServiceProvider {
    public function register(): void {
        // Via the service container:
        $this->app->make(HydeKernel::class)->registerExtension(JsonPageExtension::class);

        // Or via the facade:
        Hyde::registerExtension(JsonPageExtension::class);
    }
}
```

### Packaging your extension

To make your extension available to other HydePHP users, you can make it into a [Composer](https://getcomposer.org/) package,
and publish it to [Packagist](https://packagist.org/) for others to install.

If you register your service provider in your package's `composer.json` file, your extension automatically be enabled when
the package is installed in a HydePHP project!

```json
{
  "extra": {
    "laravel": {
      "providers": [
        "My\\Namespace\\JsonPageExtensionServiceProvider"
      ]
    }
  }
}
```

### Telling the world about your extension

Next up, why not send us a Tweet at [@HydeFramework](https://twitter.com/HydeFramework) and tell us about your extension,
so we can feature it?


--- architecture-concepts/the-hydekernel.md ---

# The HydeKernel

## Introduction

In the centre, or should I say _core_, of HydePHP is the HydeKernel. The kernel encapsulates a HydePHP project and
provides helpful methods for interacting with it. You can think of it as the heart of HydePHP, if you're a romantic.

The HydeKernel is so important that you have probably used it already. The main entry point for the HydePHP
API is the Hyde facade, which calls methods on the kernel.

```php
use Hyde\Hyde;
use Hyde\Foundation\HydeKernel;

Hyde::version(); // calls $HydeKernel->version()
```

The kernel is created very early on in the application lifecycle, in the `bootstrap.php` file, where it is also bound
as a singleton into the application service container.


## Accessing the kernel

The HydeKernel It is stored as a singleton in this class, and is bound into the
Laravel Application Service Container, and can be accessed in a few ways.

Commonly, you'll use the `Hyde` facade, but you can also use Dependency Injection
by type-hinting the `HydeKernel::class`, or use the `hyde()` function to get the Kernel.

The Kernel instance is constructed in `bootstrap.php`, and is available globally as `$hyde`.

Here are some examples of how you can call methods on the Kernel. All methods call the same method on the same instance, so it's just a matter of preference.

```php
use Hyde\Hyde;
use Hyde\Foundation\HydeKernel;

Hyde::version();
Hyde::kernel()->version();
HydeKernel::getInstance()->version();
app(HydeKernel::class)->version();
hyde()->version();
```


## The kernel lifecycle

Whenever we talk about the kernel being "booted" we are talking about the kernel's role in the autodiscovery process.

You can read all about it in the [Autodiscovery Documentation](autodiscovery).


## API Reference

Since the most common way to interact with the kernel is through the Hyde facade, we will use that for the examples.
But you could just as well chain the methods on the accessed kernel singleton instance if you wanted.

<section id="hyde-kernel-base-methods">

<!-- Start generated docs for Hyde\Foundation\HydeKernel -->
<!-- Generated by HydePHP DocGen script at 2023-03-11 11:09:45 in 2.53ms -->

#### `version()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::version(): string
```

#### `__construct()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
$hyde = new HydeKernel(string $basePath): void
```

#### `features()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::features(): Hyde\Facades\Features
```

#### `hasFeature()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::hasFeature(string $feature): bool
```

#### `toArray()`

Get the instance as an array.

```php
// torchlight! {"lineNumbers": false}
Hyde::toArray(): array<TKey, TValue>
```

<!-- End generated docs for Hyde\Foundation\HydeKernel -->

</section>

<section id="hyde-kernel-foundation-methods">

<!-- Start generated docs for Hyde\Foundation\Concerns\HandlesFoundationCollections -->
<!-- Generated by HydePHP DocGen script at 2023-03-11 11:14:55 in 0.06ms -->

#### `files()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::files(): \Hyde\Foundation\Kernel\FileCollection<string, \Hyde\Support\Filesystem\ProjectFile>
```

#### `pages()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::pages(): \Hyde\Foundation\Kernel\PageCollection<string, \Hyde\Pages\Concerns\HydePage>
```

#### `routes()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::routes(): \Hyde\Foundation\Kernel\RouteCollection<string, \Hyde\Support\Models\Route>
```

<!-- End generated docs for Hyde\Foundation\Concerns\HandlesFoundationCollections -->

</section>

<section id="hyde-kernel-string-methods">

<!-- Start generated docs for Hyde\Foundation\Concerns\ImplementsStringHelpers -->
<!-- Generated by HydePHP DocGen script at 2023-03-11 11:17:34 in 0.07ms -->

#### `makeTitle()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::makeTitle(string $value): string
```

#### `normalizeNewlines()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::normalizeNewlines(string $string): string
```

#### `stripNewlines()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::stripNewlines(string $string): string
```

#### `trimSlashes()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::trimSlashes(string $string): string
```

#### `markdown()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::markdown(string $text, bool $normalizeIndentation): Illuminate\Support\HtmlString
```

<!-- End generated docs for Hyde\Foundation\Concerns\ImplementsStringHelpers -->

</section>

<section id="hyde-kernel-hyperlink-methods">

<!-- Start generated docs for Hyde\Foundation\Concerns\ForwardsHyperlinks -->
<!-- Generated by HydePHP DocGen script at 2023-03-11 11:17:34 in 0.09ms -->

#### `formatLink()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::formatLink(string $destination): string
```

#### `relativeLink()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::relativeLink(string $destination): string
```

#### `mediaLink()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::mediaLink(string $destination, bool $validate): string
```

#### `asset()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::asset(string $name, bool $preferQualifiedUrl): string
```

#### `url()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::url(string $path): string
```

#### `hasSiteUrl()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::hasSiteUrl(): bool
```

<!-- End generated docs for Hyde\Foundation\Concerns\ForwardsHyperlinks -->

</section>

<section id="hyde-kernel-filesystem-methods">

<!-- Start generated docs for Hyde\Foundation\Concerns\ForwardsFilesystem -->
<!-- Generated by HydePHP DocGen script at 2023-03-11 11:17:34 in 0.10ms -->

#### `filesystem()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::filesystem(): Hyde\Foundation\Kernel\Filesystem
```

#### `path()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::path(string $path): string
```

#### `vendorPath()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::vendorPath(string $path, string $package): string
```

#### `mediaPath()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::mediaPath(string $path): string
```

#### `sitePath()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::sitePath(string $path): string
```

#### `siteMediaPath()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::siteMediaPath(string $path): string
```

#### `pathToAbsolute()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::pathToAbsolute(array|string $path): array|string
```

#### `pathToRelative()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::pathToRelative(string $path): string
```

<!-- End generated docs for Hyde\Foundation\Concerns\ForwardsFilesystem -->

</section>

<section id="hyde-kernel-kernel-methods">

<!-- Start generated docs for Hyde\Foundation\Concerns\ManagesHydeKernel -->
<!-- Generated by HydePHP DocGen script at 2023-03-11 11:17:34 in 0.12ms -->

#### `getInstance()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::getInstance(): Hyde\Foundation\HydeKernel
```

#### `setInstance()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::setInstance(Hyde\Foundation\HydeKernel $instance): void
```

#### `getBasePath()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::getBasePath(): string
```

#### `setBasePath()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::setBasePath(string $basePath): void
```

#### `getSourceRoot()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::getSourceRoot(): string
```

#### `setSourceRoot()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::setSourceRoot(string $sourceRoot): void
```

#### `getOutputDirectory()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::getOutputDirectory(): string
```

#### `setOutputDirectory()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::setOutputDirectory(string $outputDirectory): void
```

#### `getMediaDirectory()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::getMediaDirectory(): string
```

#### `setMediaDirectory()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::setMediaDirectory(string $mediaDirectory): void
```

#### `getMediaOutputDirectory()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::getMediaOutputDirectory(): string
```

<!-- End generated docs for Hyde\Foundation\Concerns\ManagesHydeKernel -->

</section>

<section id="hyde-kernel-extensions-methods">

<!-- Start generated docs for Hyde\Foundation\Concerns\ManagesExtensions -->
<!-- Generated by HydePHP DocGen script at 2023-03-11 11:17:34 in 0.12ms -->

#### `registerExtension()`

Register a HydePHP extension within the HydeKernel.

Typically, you would call this method in the register method of a service provider. If your package uses the standard Laravel (Composer) package discovery feature, the extension will automatically be enabled when the package is installed.

```php
// torchlight! {"lineNumbers": false}
Hyde::registerExtension(class-string&lt;\Hyde\Foundation\Concerns\HydeExtension&gt; $extension): void
```

#### `getExtension()`

Get the singleton instance of the specified extension.

```php
// torchlight! {"lineNumbers": false}
Hyde::getExtension(class-string&lt;T&gt; $extension): T
```

#### `hasExtension()`

Determine if the specified extension is registered.

```php
// torchlight! {"lineNumbers": false}
Hyde::hasExtension(class-string&lt;\Hyde\Foundation\Concerns\HydeExtension&gt; $extension): bool
```

#### `getExtensions()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::getExtensions(): array<\Hyde\Foundation\Concerns\HydeExtension>
```

#### `getRegisteredExtensions()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::getRegisteredExtensions(): array<class-string<\Hyde\Foundation\Concerns\HydeExtension>>
```

#### `getRegisteredPageClasses()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::getRegisteredPageClasses(): array<class-string<\Hyde\Pages\Concerns\HydePage>>
```

<!-- End generated docs for Hyde\Foundation\Concerns\ManagesExtensions -->

</section>

<section id="hyde-kernel-view-methods">

<!-- Start generated docs for Hyde\Foundation\Concerns\ManagesViewData -->
<!-- Generated by HydePHP DocGen script at 2023-03-11 11:17:34 in 0.06ms -->

#### `shareViewData()`

Share data for the page being rendered.

```php
// torchlight! {"lineNumbers": false}
Hyde::shareViewData(Hyde\Pages\Concerns\HydePage $page): void
```

#### `currentRouteKey()`

Get the route key for the page being rendered.

```php
// torchlight! {"lineNumbers": false}
Hyde::currentRouteKey(): string
```

#### `currentRoute()`

Get the route for the page being rendered.

```php
// torchlight! {"lineNumbers": false}
Hyde::currentRoute(): Hyde\Support\Models\Route
```

#### `currentPage()`

Get the page being rendered.

```php
// torchlight! {"lineNumbers": false}
Hyde::currentPage(): Hyde\Pages\Concerns\HydePage
```

<!-- End generated docs for Hyde\Foundation\Concerns\ManagesViewData -->

</section>

<section id="hyde-kernel-boot-methods">

<!-- Start generated docs for Hyde\Foundation\Concerns\BootsHydeKernel -->
<!-- Generated by HydePHP DocGen script at 2023-03-11 11:17:34 in 0.09ms -->

#### `isBooted()`

Determine if the Kernel has booted.

```php
// torchlight! {"lineNumbers": false}
Hyde::isBooted(): bool
```

#### `boot()`

Boot the Hyde Kernel and run the Auto-Discovery Process.

```php
// torchlight! {"lineNumbers": false}
Hyde::boot(): void
```

#### `booting()`

Register a new boot listener.

Your callback will be called before the kernel is booted. You can use this to register your own routes, pages, etc. The kernel instance will be passed to your callback.

```php
// torchlight! {"lineNumbers": false}
/** @param callable(\Hyde\Foundation\HydeKernel): void $callback */
Hyde::booting(callable(\Hyde\Foundation\HydeKernel): void): void
```

#### `booted()`

Register a new &quot;booted&quot; listener.

Your callback will be called after the kernel is booted. You can use this to run any logic after discovery has completed. The kernel instance will be passed to your callback.

```php
// torchlight! {"lineNumbers": false}
/** @param callable(\Hyde\Foundation\HydeKernel): void $callback */
Hyde::booted(callable(\Hyde\Foundation\HydeKernel): void): void
```

<!-- End generated docs for Hyde\Foundation\Concerns\BootsHydeKernel -->

</section>


--- architecture-concepts/autodiscovery.md ---

# Autodiscovery

## Introduction

HydePHP aims to reduce the amount of configuration you need to do to get a site up and running.
To that end, Hyde uses a process called autodiscovery to automatically find and register your pages.

This article will go into detail about how autodiscovery works as well as the lifecycle of the HydeKernel.

### The short version

Hyde will use the information in the page model classes to scan the source directories for matching files which are
parsed using instructions from the model's class, resulting in data used to construct objects that get stored in the HydeKernel.

### Prerequisites

Before reading this article, you should be familiar with the following concepts:
-  [Page Models](page-models)
-  [The HydeKernel](the-hydekernel)


## Booting pipeline

The autodiscovery is run when the HydeKernel boots. It does so in three distinct steps, which run in sequence as each
step depends on the previous one. Each discovery step runs in a `FoundationCollection` which both runs the actual
discovery process and stores the discovered data in memory.

#### The steps are as follows:

1. **Step one:** The file collection discovers all the source files and stores them in memory
2. **Step two:** The page collection parses all the source files into page model objects
3. **Step three:** The route collection generates route objects for all the pages

#### Interacting with the collections

Usually, you will interact with the collection data through intermediaries.
* For example, if you call `MarkdownPost::get('my-post')`, Hyde will retrieve that page from the page collection.
* If you call `Routes::get('index')`, Hyde will retrieve that route from the route collection.


## The HydeKernel

If you have not yet read the [HydeKernel Documentation](the-hydekernel), here's a quick recap:

The HydeKernel encapsulates a HydePHP project, providing helpful methods for interacting with it.
It is also responsible for booting the application, which includes the autodiscovery process.

The kernel is created very early on in the application lifecycle, in the `bootstrap.php` file, where it is also bound
as a singleton into the application service container.

At this point you might be wondering why we're talking about the kernel when this article is about autodiscovery.
Well, as you'll see in just a moment, the kernel is responsible for initiating the autodiscovery process.
The kernel is also where the discovered data is stored in memory, so it's important to understand how it works.

### The kernel lifecycle

Now that we know the role of the HydeKernel, let's take a look at its lifecycle. The kernel is "lazy-booted", meaning
that the all the heavy lifting only happens when you actually need it. Once booted, the kernel data will stay in memory
until the console application is terminated.

The kernel data is primarily stored in three collections that get generated during the kernel's boot process.
Let's take a look at a simplified version of the kernel's boot method to see how this works.

```php
public function boot(): void
{
    $this->files = FileCollection::boot($this);
    $this->pages = PageCollection::boot($this);
    $this->routes = RouteCollection::boot($this);

    // Scroll down to see what this is used for
    $this->booted = true;
}
```

Here you'll see that we boot the three collections. This is where all the autodiscovery magic happens!

#### Deep dive into lazy-booting

If you're curious about how the kernel is lazy-booted, here's how it works!
Feel free to skip this section if this doesn't interest you.

```php
// This will boot the kernel if it hasn't been booted yet
public function pages(): PageCollection
{
    $this->needsToBeBooted();

    return $this->pages;
}

// This is the method that triggers the boot process
protected function needsToBeBooted(): void
{
    if (! $this->booted) {
        $this->boot();
    }
}
```

Yeah, it's really unglamorous I know. But it works! Having it like this will ensure that any time you call `Hyde::pages()`,
that underlying collection will always have been booted and be ready to use.


--- architecture-concepts/automatic-routing.md ---

## Automatic Routing

>info This covers an intermediate topic which is not required for basic usage, but is useful if you want to use the framework to design custom Blade templates.

### High-level overview

If you've ever worked in an MVC framework, you are probably familiar with the concept of routing.
And you are probably also familiar with how boring and tedious it can be. Thankfully, Hyde takes the pain out of routing
through the Hyde Autodiscovery process.

Internally, when booting the HydeCLI application, Hyde will automatically discover all the content files in the source
directories, and create a route index for all of them. This index works as a two-way link between source files and compiled files.

Don't worry if this sounds complex, as the key takeaway is that the index is created and maintained automatically.
Nevertheless, the routing system provides several helpers that you can optionally use in your Blade views to
automatically resolve relative links and other useful features.

You can see all the routes and their corresponding source files by running the `hyde route:list` command.

```bash
php hyde route:list
```

### Accessing routes

Each route in your site is represented by a Route object. It's very easy to get a Route object instance from the Router's index.
There are a few ways to do this, but most commonly you'll use the Routes facade's `get()` method where you provide a route key,
and it will return the Route object. The route key is generally `<page-output-directory/page-identifier>`. Here are some examples:

```php
// Source file: _pages/index.md/index.blade.php
// Compiled file: _site/index.html
Routes::get('index')

// Source file: _posts/my-post.md
// Compiled file: _site/posts/my-post.html
Routes::get('posts/my-post')

// Source file: _docs/readme.md
// Compiled file: _site/docs/readme.html
Routes::get('docs/readme')
```

### Using the `x-link` component

When designing Blade layouts it can be useful to use the `x-link` component to automatically resolve relative links.

You can of course, use it just like a normal anchor tag like so:

```blade
<x-link href="index.html">Home</x-link>
```

But where it really shines is when you supply a route. This will then resolve the proper relative link, and format it to use pretty URLs if your site is configured to use them.

```blade
<x-link :href="Routes::get('index')">Home</x-link>
```

You can of course, also supply extra attributes like classes:

```blade
<x-link :href="Routes::get('index')" class="btn btn-primary">Home</x-link>
```


--- architecture-concepts/page-models.md ---


# The Hyde Page Models

## Introduction

The Hyde page models are an integral part of how HydePHP creates your static site. Each page in your site is represented
by a page model. These are simply PHP classes that in addition to holding both the source content and computed data
for your pages, also house instructions to Hyde on how to parse, process, and render the pages to static HTML.

In this article, you'll get a high-level overview of the page models, and some code examples to give you a look inside.


## The short version

#### Page models are classes that have two primary concerns:

1. They act as blueprints containing _static_ instructions for how to parse, process, and, render pages.
2. Each class _instance_ also holds the page source contents, as well as the computed data.

#### Other key points:

- HydePHP, at the time of writing, comes with five different page classes, one for each supported type.
- You don't construct page models yourself. HydePHP does it for you by the [autodiscovery process](autodiscovery).
- Page models are just PHP classes. You can extend them, and you can implement your own.


## The Page Model

To give you an idea of what a page model class looks like, here's a simplified version of the base `MarkdownPost` class,
Don't worry if you don't understand everything yet, we'll talk more about these parts later.

```php
class MarkdownPost extends BaseMarkdownPage
{
    public static string $sourceDirectory = '_posts';
    public static string $outputDirectory = 'posts';
    public static string $fileExtension = '.md';
    public static string $template = 'post';

    public string $identifier;
    public string $routeKey;
    public string $title;

    public FrontMatter $matter;
    public Markdown $markdown;
}
```

_Note that since Hyde pages are modular through class inheritance and traits, this example has been simplified and
edited to show all the relevant parts inlined into one class._


## Page Models as Blueprints

All page models have some static properties (that is, they belong to the class, not the instance) that are used as
blueprints, defining information for Hyde to know how to parse a file, and what data around it should be generated.

Let's again take the simplified `MarkdownPost` class as an example, this time only showing the static properties:

```php
class MarkdownPost extends BaseMarkdownPage
{
    public static string $sourceDirectory = '_posts';
    public static string $outputDirectory = 'posts';
    public static string $fileExtension = '.md';
    public static string $template = 'post';
}
```

#### What each property does

The properties should be self-explanatory, but here's a quick rundown to give some context on how they are used,
and how the paths relate to each other. So for the class above, Hyde will thanks to this blueprint, know to:
* Look for files in the `_posts` directory, with the `.md` extension
* Compile the page using the `post` Blade template
* Output the compiled page to the `_site/posts` directory


## Page Models as Data Containers

As mentioned above, each page model instance also holds the page source contents, as well as the computed data.

Let's again take the simplified `MarkdownPost` class as an example, this time only showing the instance properties:

```php
class MarkdownPost extends BaseMarkdownPage
{
    public string $identifier;
    public string $routeKey;
    public string $title;

    public FrontMatter $matter;
    public Markdown $markdown;
}
```

There are some more properties than shown here, for example, various metadata properties, but these are the most common
and important ones.

While the static data gives instructions to Hyde on how to process all pages of the type, the instance data tells Hyde
how to process a specific page. For example, the identifier property is used to uniquely identify the page, and
the routeKey property is used to generate the URL for the page.

The matter and markdown properties as I'm sure you can guess, hold the page's front matter and markdown content.
These can then also be processed by [page factories](dynamic-data-discovery) to generate the computed data like the
title property.


--- architecture-concepts/architecture-concepts.md ---


# Advanced Architecture Concepts

## Introduction

These chapters are written for power users and package contributors. If you're just looking to get a site up and running,
you can safely skip this section. The documentation here will cover advanced topics under the presumption that
the reader has a basic to intermediate understanding of programming, as well as PHP, object-oriented design,
and to some extent Laravel, as the articles are heavily driven by code examples.

You are of course free to skip this entire section, as you don't need to know these things to use Hyde.
However, if you want to know the "magic" behind Hyde, or if you want to take advantage of these powerful tools,
then by all means, please read on! This is also a great place to start if you want to contribute to the source code.

>info For a high-level overview of these concepts, see the [Basic Architecture Concepts](core-concepts) page.


## Behind the magic

Want to learn more about a particular feature? Click on the links below to visit the article.

[//]: # (This would be better suited for a component, but it's a fun experiment for now)
[Blade]: <ul>@foreach(glob(DocumentationPage::path('architecture-concepts/*.md')) as $file) <li> <a href="{{ basename($file, '.md') }}.html"> {{ Hyde::makeTitle(basename($file, '.md')) }} </a> </li> @endforeach</ul>


--- advanced-features/build-tasks.md ---

# Custom Build Tasks

## Introduction

The Build Task API offers a simple way to hook into the build process.
The build tasks are very powerful and allow for limitless customizability.

The built-in Hyde features like sitemap generation and RSS feeds are created using tasks like these.
Maybe you want to create your own, to for example upload the site to FTP or copy the files to a public directory?
You can also overload the built-in tasks to customize them to your needs.


## Good to know before you start

### Types of tasks

There are two types, PreBuildTasks and PostBuildTasks. As the names suggest, PreBuildTasks are executed before the site is built, and PostBuildTasks are executed after the site is built.

To choose which type of task you want to create, you extend either the `PreBuildTask` or `PostBuildTask` class.
Both of these have the exact same helpers and API available, so the only difference between them is when they are executed. The classes are otherwise identical.

### About these examples

For most of these examples we will focus on the PostBuildTasks as they are the most common.

For all these examples we assume you put the file in the `App/Actions` directory, but you can put them anywhere.

### Interacting with output

In a way, build tasks are like micro-commands, as they can interact directly with the build commands I/O. Please take a look at the [Laravel Console Documentation](https://laravel.com/docs/10.x/artisan#command-io) for the full list of available methods.

In addition, there are some extra helpers available in the base BuildTask class that allow you to fluently format output to the console, which you will see in the examples below.


## Creating build tasks

### Minimal example

Here is a minimal example to give you an idea of what we are working with.

```php
class SimpleBuildTask extends PostBuildTask
{
    public function handle(): void
    {
        //
    }
}
```

As you can see, at their core, build tasks are simple classes containing a `handle()` method,
which as I'm sure you have guessed, is the method that is executed when the task is run by the build command.

If you want the task to run before the build, you would extend the `PreBuildTask` class instead.

#### Automatic output

When running the build command, you will see the following output added after the build is complete.

<pre>
 <span style="color: gold">Generic build task...</span> <span style="color: gray">Done in 0.26ms</span>
</pre>

As you can see, some extra output including execution time tracking is added for us. We can of course customize all of this if we want, as you will learn a bit further down.

### Full example

Here is a full example, with all the namespaces included, as well as the most common fluent output helpers.

```php
<?php

namespace App\Actions;

use Hyde\Framework\Features\BuildTasks\PostBuildTask;

class ExampleTask extends PostBuildTask
{
    public static string $message = 'Say hello';

    public function handle(): void
    {
        $this->info('Hello World!');
    }

    public function printFinishMessage(): void
    {
        $this->line('Goodbye World!');
    }
}
```

You can see a full API reference further below. But in short, the `$message` property is the message that runs before the task is executed, and the `printFinishMessage()` method is the message that runs after the task is executed.

Running this task will produce the following output:

<pre>
<small style="color: gray">$ php hyde build</small>
  <span style="color: gold">Say hello...</span> <span style="color: green">Hello World!</span>
  Goodbye World!
</pre>

As you can see, there is no execution time tracking here, since we overrode the `printFinishMessage()` method that normally prints this. You can of course call the `withExecutionTime()` method to add this back in. See more in the API reference below.


## Registering the tasks

There are a few ways to register these tasks so Hyde can find them.

They are shown here in order of presumed convenience, but you are free to choose whichever you prefer. The latter options are more suited for extension developers.

### Autodiscovery registration

The easiest way to register build tasks, is to not do it. Just let Hyde do it for you!

Any classes that end in `BuildTask.php` that are stored in `app/Actions`  will be autoloaded and registered to run automatically.

For example: `app/Actions/ExampleBuildTask.php`.

### Config file registration

If you want, you can also register build tasks of any namespace in the convenient `build_tasks` array which is in the main configuration file, `config/hyde.php`.

```php
// filepath config/hyde.php
'build_tasks' => [
    \App\Actions\SimpleTask::class,
    \MyPackage\Tasks\MyBuildTask::class,
],
```

### Programmatic registration

>info This option assumes you are familiar with Laravel's service container and service providers.

If you are developing an extension, you can either instruct users register your tasks with the config option above,
or you can register the extensions programmatically, I recommend you do this in the `boot` method of a service provider.

The build tasks are registered in an internal array of the `BuildService` class, which is bound as a singleton in the underlying Laravel service container.
To actually register your task, provide the fully qualified class name of the task to the `BuildTaskService::registerTask()` method.

Here is an example of how to do this using in a service provider. Though you could technically do it anywhere using the `app()` helper, just as long as it's done early enough in the application lifecycle, so it's registered before the build command is executed.

```php
class MyServiceProvider extends ServiceProvider
{
    public function boot(): void
    {
        $this->app->make(\Hyde\Framework\Services\BuildTaskService::class)
            ->registerTask(\MyPackage\Tasks\MyBuildTask::class);
    }
}
```


--- advanced-features/hyde-pages.md ---


# HydePage API Reference

>warning This article covers advanced information, and you are expected to already be familiar with [Page Models](page-models) and OOP


## Abstract

This page contains the full API references for the built-in HydePage classes. Most users will not need to know about
the inner workings of classes, but if you're interested in extending HydePHP, or just curious, this page is for you.
It is especially useful if you're looking to implement your own page classes, or if you are creating advanced Blade templates.

### About the reference

This document is heavily based around the actual source code, as I believe the best way to understand the code is to read it.
However, large parts of the code are simplified for brevity and illustration. The code is not meant to be copy-pasted, but
rather used as a reference so that you know what to look for in the actual source code, if you want to dig deeper.

#### Inheritance

Since all HydePages extend the base `HydePage` class, those shared methods are only listed once,
under the `HydePage` class documentation which is conveniently located just below this section.

### Table of Contents

| Class                                   | Description                            |
|-----------------------------------------|----------------------------------------|
| [HydePage](#hydepage)                   | The base class for all Hyde pages.     |
| [BaseMarkdownPage](#basemarkdownpage)   | The base class for all Markdown pages. |
| [InMemoryPage](#inmemorypage)           | Extendable class for in-memory pages.  |
| [BladePage](#markdownpage)              | Class for Blade pages.                 |
| [MarkdownPage](#markdownpage)           | Class for Markdown pages.              |
| [MarkdownPost](#markdownpost)           | Class for Markdown posts.              |
| [DocumentationPage](#documentationpage) | Class for documentation pages.         |
| [HtmlPage](#htmlpage)                   | Class for HTML pages.                  |


## HydePage

The base class for all Hyde pages, all other page classes extend this class.

Unlike other frameworks, in general you don't instantiate pages yourself in Hyde, instead, the page models acts as
blueprints defining information for Hyde to know how to parse a file, and what data around it should be generated.

To create a parsed file instance, you'd typically just create a source file, and you can then access the parsed file
from the HydeKernel's page index.

In Blade views, you can always access the current page instance being rendered using the `$page` variable.

### Quick Reference

| Class Name | Namespace             | Source Code                                                                                        | API Docs                                                                                                     |
|------------|-----------------------|----------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------|
| `HydePage` | `Hyde\Pages\Concerns` | [Open in GitHub](https://github.com/hydephp/framework/blob/master/src/Pages/Concerns/HydePage.php) | [Live API Docs](https://hydephp.github.io/develop/master/api-docs/classes/Hyde-Pages-Concerns-HydePage.html) |

### Base Structure

```php
/**
 * The base class for all Hyde pages. Here simplified for the sake of brevity.
 */
abstract class HydePage
{
    /**
     * The directory in which source files are stored. Relative to the project root.
     */
    public static string $sourceDirectory;

    /**
     * The output subdirectory to store compiled HTML. Relative to the _site output directory.
     */
    public static string $outputDirectory;

    /**
     * The file extension of the source files.
     */
    public static string $fileExtension;

    /**
     * The default template to use for rendering the page.
     */
    public static string $template;

    /**
     * The page instance identifier.
     */
    public readonly string $identifier;

    /**
     * The page instance route key.
     */
    public readonly string $routeKey;

    /**
     * The parsed front matter.
     */
    public FrontMatter $matter;

    /**
     * The generated page metadata.
     */
    public PageMetadataBag $metadata;

    /**
     * The generated page navigation data.
     */
    public NavigationData $navigation;
}
```

### Methods

>warning <p class="p-2" style="padding-right: 1rem"><strong>Heads up!</strong> The following methods are defined in the <code>HydePage</code> class, and are thus available to all page classes. Since the HydePage class is abstract, you cannot instantiate it directly, and many of the static methods are also only callable from the child classes.</p>

[Blade]: {{ Hyde\Markdown\Models\Markdown::fromFile(DocumentationPage::sourcePath('_data/partials/hyde-pages-api/hyde-page-methods'))->toHtml($page::class) }}

[Blade]: {{ Hyde\Markdown\Models\Markdown::fromFile(DocumentationPage::sourcePath('_data/partials/hyde-pages-api/interacts-with-front-matter-methods'))->toHtml($page::class) }}


## BaseMarkdownPage

The base class for all Markdown-based page models, with additional helpers tailored for Markdown pages.

### Quick Reference

| Class Name         | Namespace             | Source Code                                                                                                | API Docs                                                                                                             |
|--------------------|-----------------------|------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------|
| `BaseMarkdownPage` | `Hyde\Pages\Concerns` | [Open in GitHub](https://github.com/hydephp/framework/blob/master/src/Pages/Concerns/BaseMarkdownPage.php) | [Live API Docs](https://hydephp.github.io/develop/master/api-docs/classes/Hyde-Pages-Concerns-BaseMarkdownPage.html) |

### Base Structure

```php
/**
 * The base class for all Markdown-based page models. Here simplified for the sake of brevity.
 */
abstract class BaseMarkdownPage extends HydePage
{
    public Markdown $markdown;

    public static string $fileExtension = '.md';
}
```

### Methods

[Blade]: {{ Hyde\Markdown\Models\Markdown::fromFile(DocumentationPage::sourcePath('_data/partials/hyde-pages-api/base-markdown-page-methods'))->toHtml($page::class) }}


## InMemoryPage

Before we take a look at the common page classes, you'll usually use, let's first take a look at one that's quite interesting.

This class is especially useful for one-off custom pages. But if your usage grows, or if you want to utilize Hyde
autodiscovery, you may benefit from creating a custom page class instead, as that will give you full control.

You can learn more about the InMemoryPage class in the [InMemoryPage documentation](in-memory-pages).

### Quick Reference

| Class Name     | Namespace    | Source Code                                                                                   | API Docs                                                                                                |
|----------------|--------------|-----------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------|
| `InMemoryPage` | `Hyde\Pages` | [Open in GitHub](https://github.com/hydephp/framework/blob/master/src/Pages/InMemoryPage.php) | [Live API Docs](https://hydephp.github.io/develop/master/api-docs/classes/Hyde-Pages-InMemoryPage.html) |

### Base Structure

As the class is not discoverable, the static path properties are not initialized. Instead, you solely rely on the contents/view properties.

You can also define macros which allow you to both add methods to the instance, but also to overload some built-in ones like the `compile` method.

```php
/**
 * The InMemoryPage class, here simplified for the sake of brevity.
 */
class InMemoryPage extends HydePage
{
    public static string $sourceDirectory;
    public static string $outputDirectory;
    public static string $fileExtension;

    protected string $contents;
    protected string $view;

    /** @var array<string, callable> */
    protected array $macros = [];
}
```

### Methods

[Blade]: {{ Hyde\Markdown\Models\Markdown::fromFile(DocumentationPage::sourcePath('_data/partials/hyde-pages-api/in-memory-page-methods'))->toHtml($page::class) }}


## BladePage

Page class for Blade pages.

Blade pages are stored in the _`pages` directory and using the `.blade.php` extension.
They will be compiled using the Laravel Blade engine the `_site/` directory.

### Quick Reference

| Class Name  | Namespace    | Source Code                                                                                | API Docs                                                                                             |
|-------------|--------------|--------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------|
| `BladePage` | `Hyde\Pages` | [Open in GitHub](https://github.com/hydephp/framework/blob/master/src/Pages/BladePage.php) | [Live API Docs](https://hydephp.github.io/develop/master/api-docs/classes/Hyde-Pages-BladePage.html) |

### Base Structure

```php
class BladePage extends HydePage
{
    public static string $sourceDirectory = '_pages';
    public static string $outputDirectory = '';
    public static string $fileExtension = '.blade.php';
}
```

### Methods

[Blade]: {{ Hyde\Markdown\Models\Markdown::fromFile(DocumentationPage::sourcePath('_data/partials/hyde-pages-api/blade-page-methods'))->toHtml($page::class) }}


## MarkdownPage

Page class for Markdown pages.

Markdown pages are stored in the _`pages` directory and using the `.md` extension.
The Markdown will be compiled to HTML using a minimalistic layout to the `_site/` directory.

### Quick Reference

| Class Name     | Namespace    | Source Code                                                                                   | API Docs                                                                                                |
|----------------|--------------|-----------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------|
| `MarkdownPage` | `Hyde\Pages` | [Open in GitHub](https://github.com/hydephp/framework/blob/master/src/Pages/MarkdownPage.php) | [Live API Docs](https://hydephp.github.io/develop/master/api-docs/classes/Hyde-Pages-MarkdownPage.html) |

### Base Structure

```php
class MarkdownPage extends BaseMarkdownPage
{
    public static string $sourceDirectory = '_pages';
    public static string $outputDirectory = '';
    public static string $template = 'hyde::layouts/page';
}
```

### Methods

This class does not define any additional methods.


## MarkdownPost

Page class for Markdown blog posts.

Markdown posts are stored in the `_posts` directory and using the `.md` extension.
The Markdown will be compiled to HTML using the blog post layout to the `_site/posts/` directory.

### Quick Reference

| Class Name     | Namespace    | Source Code                                                                                   | API Docs                                                                                                |
|----------------|--------------|-----------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------|
| `MarkdownPost` | `Hyde\Pages` | [Open in GitHub](https://github.com/hydephp/framework/blob/master/src/Pages/MarkdownPost.php) | [Live API Docs](https://hydephp.github.io/develop/master/api-docs/classes/Hyde-Pages-MarkdownPost.html) |

### Base Structure

```php
class MarkdownPost extends BaseMarkdownPage
{
    public static string $sourceDirectory = '_posts';
    public static string $outputDirectory = 'posts';
    public static string $template = 'hyde::layouts/post';

    public ?string $description;
    public ?string $category;
    public ?DateString $date;
    public ?PostAuthor $author;
    public ?FeaturedImage $image;
}
```

### Methods

[Blade]: {{ Hyde\Markdown\Models\Markdown::fromFile(DocumentationPage::sourcePath('_data/partials/hyde-pages-api/markdown-post-methods'))->toHtml($page::class) }}


## DocumentationPage

Page class for documentation pages.

Documentation pages are stored in the `_docs` directory and using the `.md` extension.
The Markdown will be compiled to HTML using the documentation page layout to the `_site/docs/` directory.

### Quick Reference

| Class Name          | Namespace    | Source Code                                                                                        | API Docs                                                                                                     |
|---------------------|--------------|----------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------|
| `DocumentationPage` | `Hyde\Pages` | [Open in GitHub](https://github.com/hydephp/framework/blob/master/src/Pages/DocumentationPage.php) | [Live API Docs](https://hydephp.github.io/develop/master/api-docs/classes/Hyde-Pages-DocumentationPage.html) |

### Base Structure

```php
class DocumentationPage extends BaseMarkdownPage
{
    public static string $sourceDirectory = '_docs';
    public static string $outputDirectory = 'docs';
    public static string $template = 'hyde::layouts/docs';
}
```

### Methods

[Blade]: {{ Hyde\Markdown\Models\Markdown::fromFile(DocumentationPage::sourcePath('_data/partials/hyde-pages-api/documentation-page-methods'))->toHtml($page::class) }}


## HtmlPage

Page class for HTML pages.

Html pages are stored in the `_pages` directory and using the `.html` extension.
These pages will be copied exactly as they are to the `_site/` directory.

### Quick Reference

| Class Name | Namespace    | Source Code                                                                               | API Docs                                                                                            |
|------------|--------------|-------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------|
| `HtmlPage` | `Hyde\Pages` | [Open in GitHub](https://github.com/hydephp/framework/blob/master/src/Pages/HtmlPage.php) | [Live API Docs](https://hydephp.github.io/develop/master/api-docs/classes/Hyde-Pages-HtmlPage.html) |

### Base Structure

```php
class HtmlPage extends HydePage
{
    public static string $sourceDirectory = '_pages';
    public static string $outputDirectory = '';
    public static string $fileExtension = '.html';
}
```

### Methods

[Blade]: {{ Hyde\Markdown\Models\Markdown::fromFile(DocumentationPage::sourcePath('_data/partials/hyde-pages-api/html-page-methods'))->toHtml($page::class) }}


--- advanced-features/advanced-features.md ---


# Advanced Features in HydePHP

## Preface

HydePHP is a simple, yet powerful, static site generator. It is designed to be easy to use and easy to extend.

This section of the documentation will cover some of the more advanced (but optional) features of the framework.


## Prerequisites

To fully understand the features described in these chapters, it may be beneficial to first skim through the
[Architecture Concepts](architecture-concepts) chapters, or at the very least, the [Core Concepts](core-concepts) page.

You are also expected to have a basic understanding of PHP, and object-oriented programming principles.

Having some familiarity with Laravel will also be beneficial, as HydePHP is built on top of the Laravel framework.


## Table of Contents

[Blade]: <ul>@foreach(glob(DocumentationPage::path('advanced-features/*.md')) as $file) <li> <a href="{{ basename($file, '.md') }}.html"> {{ Hyde::makeTitle(basename($file, '.md')) }} </a> </li> @endforeach</ul>


--- advanced-features/in-memory-pages.md ---

# InMemoryPages

## Introduction

This class is a special page class that is not backed by a file on disk, but rather generated at runtime. While it will
probably not be useful for the majority of users, it's a great class to know about if you are a package developer,
but feel free to skip this section if you're not interested in this.

### When to use

This class is especially useful for one-off custom pages. But if your usage grows, or if you want to utilize Hyde
autodiscovery, you may benefit from creating a custom page class instead, as that will give you full control.

### About discovery

Since the InMemoryPages are not present in the filesystem, they cannot be found by the auto-discovery process,
thus it's up to the developer to manually register them. If you are developing for your own project, you can do this in
the `boot` method of a service provider, such as the `AppServiceProvider` which is already present in your `app/` directory.

If you are developing a package, you may instead want to register the page in your package extension class, within the
page collection callback. In either case, if you want your page to be able to be fully processed by Hyde, you need to
make sure you register it before the full application is booted so that routes can be generated.

_To see how to register the page, see the examples below, first we must look at how to actually create the page._


## Creating the page

To create an InMemoryPage, you need to instantiate it, and pass it the required parameters.

A page would not be useful without any content to render. The class offers two content options through the constructor.

You can either pass a string to the `$contents` parameter, Hyde will then save that literally as the page's contents.

```php
$page = new InMemoryPage(contents: 'Hello World!');
```

Alternatively, you can pass a Blade view name to the `$view` parameter, and Hyde will use that view to render the page
contents with the supplied front matter during the static site build process.

>warning Note that `$contents` take precedence over `$view`, so if you pass both, only `$contents` will be used.

You can also register a macro with the name `compile` to overload the default compile method.


## API Reference

To see all the methods available, please see the [InMemoryPage API reference](hyde-pages#inmemorypage).


