Start HydePHP Documentation (Framework version v1.3.3)

--- docs\advanced-features\advanced-features.md ---


# Advanced Features in HydePHP

## Preface

HydePHP is a simple, yet powerful, static site generator. It is designed to be easy to use and easy to extend.

This section of the documentation will cover some of the more advanced (but optional) features of the framework.


## Prerequisites

To fully understand the features described in these chapters, it may be beneficial to first skim through the
[Architecture Concepts](architecture-concepts) chapters, or at the very least, the [Core Concepts](core-concepts) page.

You are also expected to have a basic understanding of PHP, and object-oriented programming principles.

Having some familiarity with Laravel will also be beneficial, as HydePHP is built on top of the Laravel framework.


## Table of Contents

[Blade]: <ul>@foreach(glob(DocumentationPage::path('advanced-features/*.md')) as $file) <li> <a href="{{ basename($file, '.md') }}.html"> {{ Hyde::makeTitle(basename($file, '.md')) }} </a> </li> @endforeach</ul>


--- docs\advanced-features\build-tasks.md ---

# Custom Build Tasks

## Introduction

The Build Task API offers a simple way to hook into the build process.
The build tasks are very powerful and allow for limitless customizability.

The built-in Hyde features like sitemap generation and RSS feeds are created using tasks like these.
Maybe you want to create your own, to for example upload the site to FTP or copy the files to a public directory?
You can also overload the built-in tasks to customize them to your needs.


## Good to know before you start

### Types of tasks

There are two types, PreBuildTasks and PostBuildTasks. As the names suggest, PreBuildTasks are executed before the site is built, and PostBuildTasks are executed after the site is built.

To choose which type of task you want to create, you extend either the `PreBuildTask` or `PostBuildTask` class.
Both of these have the exact same helpers and API available, so the only difference between them is when they are executed. The classes are otherwise identical.

### About these examples

For most of these examples we will focus on the PostBuildTasks as they are the most common.

For all these examples we assume you put the file in the `App/Actions` directory, but you can put them anywhere.

### Interacting with output

In a way, build tasks are like micro-commands, as they can interact directly with the build commands I/O. Please take a look at the [Laravel Console Documentation](https://laravel.com/docs/10.x/artisan#command-io) for the full list of available methods.

In addition, there are some extra helpers available in the base BuildTask class that allow you to fluently format output to the console, which you will see in the examples below.


## Creating build tasks

### Minimal example

Here is a minimal example to give you an idea of what we are working with.

```php
class SimpleBuildTask extends PostBuildTask
{
    public function handle(): void
    {
        //
    }
}
```

As you can see, at their core, build tasks are simple classes containing a `handle()` method,
which as I'm sure you have guessed, is the method that is executed when the task is run by the build command.

If you want the task to run before the build, you would extend the `PreBuildTask` class instead.

#### Automatic output

When running the build command, you will see the following output added after the build is complete.

<pre>
 <span style="color: gold">Generic build task...</span> <span style="color: gray">Done in 0.26ms</span>
</pre>

As you can see, some extra output including execution time tracking is added for us. We can of course customize all of this if we want, as you will learn a bit further down.

### Full example

Here is a full example, with all the namespaces included, as well as the most common fluent output helpers.

```php
<?php

namespace App\Actions;

use Hyde\Framework\Features\BuildTasks\PostBuildTask;

class ExampleTask extends PostBuildTask
{
    public static string $message = 'Say hello';

    public function handle(): void
    {
        $this->info('Hello World!');
    }

    public function printFinishMessage(): void
    {
        $this->line('Goodbye World!');
    }
}
```

You can see a full API reference further below. But in short, the `$message` property is the message that runs before the task is executed, and the `printFinishMessage()` method is the message that runs after the task is executed.

Running this task will produce the following output:

<pre>
<small style="color: gray">$ php hyde build</small>
  <span style="color: gold">Say hello...</span> <span style="color: green">Hello World!</span>
  Goodbye World!
</pre>

As you can see, there is no execution time tracking here, since we overrode the `printFinishMessage()` method that normally prints this. You can of course call the `withExecutionTime()` method to add this back in. See more in the API reference below.


## Registering the tasks

There are a few ways to register these tasks so Hyde can find them.

They are shown here in order of presumed convenience, but you are free to choose whichever you prefer. The latter options are more suited for extension developers.

### Autodiscovery registration

The easiest way to register build tasks, is to not do it. Just let Hyde do it for you!

Any classes that end in `BuildTask.php` that are stored in `app/Actions`  will be autoloaded and registered to run automatically.

For example: `app/Actions/ExampleBuildTask.php`.

### Config file registration

If you want, you can also register build tasks of any namespace in the convenient `build_tasks` array which is in the main configuration file, `config/hyde.php`.

```php
// filepath config/hyde.php
'build_tasks' => [
    \App\Actions\SimpleTask::class,
    \MyPackage\Tasks\MyBuildTask::class,
],
```

### Programmatic registration

>info This option assumes you are familiar with Laravel's service container and service providers.

If you are developing an extension, you can either instruct users register your tasks with the config option above,
or you can register the extensions programmatically, I recommend you do this in the `boot` method of a service provider.

The build tasks are registered in an internal array of the `BuildService` class, which is bound as a singleton in the underlying Laravel service container.
To actually register your task, provide the fully qualified class name of the task to the `BuildTaskService::registerTask()` method.

Here is an example of how to do this using in a service provider. Though you could technically do it anywhere using the `app()` helper, just as long as it's done early enough in the application lifecycle, so it's registered before the build command is executed.

```php
class MyServiceProvider extends ServiceProvider
{
    public function boot(): void
    {
        $this->app->make(\Hyde\Framework\Services\BuildTaskService::class)
            ->registerTask(\MyPackage\Tasks\MyBuildTask::class);
    }
}
```


--- docs\advanced-features\hyde-pages.md ---



--- docs\advanced-features\in-memory-pages.md ---

# InMemoryPages

## Introduction

This class is a special page class that is not backed by a file on disk, but rather generated at runtime. While it will
probably not be useful for the majority of users, it's a great class to know about if you are a package developer,
but feel free to skip this section if you're not interested in this.

### When to use

This class is especially useful for one-off custom pages. But if your usage grows, or if you want to utilize Hyde
autodiscovery, you may benefit from creating a custom page class instead, as that will give you full control.

### About discovery

Since the InMemoryPages are not present in the filesystem, they cannot be found by the auto-discovery process,
thus it's up to the developer to manually register them. If you are developing for your own project, you can do this in
the `boot` method of a service provider, such as the `AppServiceProvider` which is already present in your `app/` directory.

If you are developing a package, you may instead want to register the page in your package extension class, within the
page collection callback. In either case, if you want your page to be able to be fully processed by Hyde, you need to
make sure you register it before the full application is booted so that routes can be generated.

_To see how to register the page, see the examples below, first we must look at how to actually create the page._


## Creating the page

To create an InMemoryPage, you need to instantiate it, and pass it the required parameters.

A page would not be useful without any content to render. The class offers two content options through the constructor.

You can either pass a string to the `$contents` parameter, Hyde will then save that literally as the page's contents.

```php
$page = new InMemoryPage(contents: 'Hello World!');
```

Alternatively, you can pass a Blade view name to the `$view` parameter, and Hyde will use that view to render the page
contents with the supplied front matter during the static site build process.

>warning Note that `$contents` take precedence over `$view`, so if you pass both, only `$contents` will be used.

You can also register a macro with the name `compile` to overload the default compile method.


## API Reference

To see all the methods available, please see the [InMemoryPage API reference](hyde-pages#inmemorypage).


--- docs\architecture-concepts\architecture-concepts.md ---


# Advanced Architecture Concepts

## Introduction

These chapters are written for power users and package contributors. If you're just looking to get a site up and running,
you can safely skip this section. The documentation here will cover advanced topics under the presumption that
the reader has a basic to intermediate understanding of programming, as well as PHP, object-oriented design,
and to some extent Laravel, as the articles are heavily driven by code examples.

You are of course free to skip this entire section, as you don't need to know these things to use Hyde.
However, if you want to know the "magic" behind Hyde, or if you want to take advantage of these powerful tools,
then by all means, please read on! This is also a great place to start if you want to contribute to the source code.

>info For a high-level overview of these concepts, see the [Basic Architecture Concepts](core-concepts) page.


## Behind the magic

Want to learn more about a particular feature? Click on the links below to visit the article.

[//]: # (This would be better suited for a component, but it's a fun experiment for now)
[Blade]: <ul>@foreach(glob(DocumentationPage::path('architecture-concepts/*.md')) as $file) <li> <a href="{{ basename($file, '.md') }}.html"> {{ Hyde::makeTitle(basename($file, '.md')) }} </a> </li> @endforeach</ul>


--- docs\architecture-concepts\autodiscovery.md ---

# Autodiscovery

## Introduction

HydePHP aims to reduce the amount of configuration you need to do to get a site up and running.
To that end, Hyde uses a process called autodiscovery to automatically find and register your pages.

This article will go into detail about how autodiscovery works as well as the lifecycle of the HydeKernel.

### The short version

Hyde will use the information in the page model classes to scan the source directories for matching files which are
parsed using instructions from the model's class, resulting in data used to construct objects that get stored in the HydeKernel.

### Prerequisites

Before reading this article, you should be familiar with the following concepts:
-  [Page Models](page-models)
-  [The HydeKernel](the-hydekernel)


## Booting pipeline

The autodiscovery is run when the HydeKernel boots. It does so in three distinct steps, which run in sequence as each
step depends on the previous one. Each discovery step runs in a `FoundationCollection` which both runs the actual
discovery process and stores the discovered data in memory.

#### The steps are as follows:

1. **Step one:** The file collection discovers all the source files and stores them in memory
2. **Step two:** The page collection parses all the source files into page model objects
3. **Step three:** The route collection generates route objects for all the pages

#### Interacting with the collections

Usually, you will interact with the collection data through intermediaries.
* For example, if you call `MarkdownPost::get('my-post')`, Hyde will retrieve that page from the page collection.
* If you call `Routes::get('index')`, Hyde will retrieve that route from the route collection.


## The HydeKernel

If you have not yet read the [HydeKernel Documentation](the-hydekernel), here's a quick recap:

The HydeKernel encapsulates a HydePHP project, providing helpful methods for interacting with it.
It is also responsible for booting the application, which includes the autodiscovery process.

The kernel is created very early on in the application lifecycle, in the `bootstrap.php` file, where it is also bound
as a singleton into the application service container.

At this point you might be wondering why we're talking about the kernel when this article is about autodiscovery.
Well, as you'll see in just a moment, the kernel is responsible for initiating the autodiscovery process.
The kernel is also where the discovered data is stored in memory, so it's important to understand how it works.

### The kernel lifecycle

Now that we know the role of the HydeKernel, let's take a look at its lifecycle. The kernel is "lazy-booted", meaning
that the all the heavy lifting only happens when you actually need it. Once booted, the kernel data will stay in memory
until the console application is terminated.

The kernel data is primarily stored in three collections that get generated during the kernel's boot process.
Let's take a look at a simplified version of the kernel's boot method to see how this works.

```php
public function boot(): void
{
    $this->files = FileCollection::boot($this);
    $this->pages = PageCollection::boot($this);
    $this->routes = RouteCollection::boot($this);

    // Scroll down to see what this is used for
    $this->booted = true;
}
```

Here you'll see that we boot the three collections. This is where all the autodiscovery magic happens!

#### Deep dive into lazy-booting

If you're curious about how the kernel is lazy-booted, here's how it works!
Feel free to skip this section if this doesn't interest you.

```php
// This will boot the kernel if it hasn't been booted yet
public function pages(): PageCollection
{
    $this->needsToBeBooted();

    return $this->pages;
}

// This is the method that triggers the boot process
protected function needsToBeBooted(): void
{
    if (! $this->booted) {
        $this->boot();
    }
}
```

Yeah, it's really unglamorous I know. But it works! Having it like this will ensure that any time you call `Hyde::pages()`,
that underlying collection will always have been booted and be ready to use.


--- docs\architecture-concepts\automatic-routing.md ---

## Automatic Routing

>info This covers an intermediate topic which is not required for basic usage, but is useful if you want to use the framework to design custom Blade templates.

### High-level overview

If you've ever worked in an MVC framework, you are probably familiar with the concept of routing.
And you are probably also familiar with how boring and tedious it can be. Thankfully, Hyde takes the pain out of routing
through the Hyde Autodiscovery process.

Internally, when booting the HydeCLI application, Hyde will automatically discover all the content files in the source
directories, and create a route index for all of them. This index works as a two-way link between source files and compiled files.

Don't worry if this sounds complex, as the key takeaway is that the index is created and maintained automatically.
Nevertheless, the routing system provides several helpers that you can optionally use in your Blade views to
automatically resolve relative links and other useful features.

You can see all the routes and their corresponding source files by running the `hyde route:list` command.

```bash
php hyde route:list
```

### Accessing routes

Each route in your site is represented by a Route object. It's very easy to get a Route object instance from the Router's index.
There are a few ways to do this, but most commonly you'll use the Routes facade's `get()` method where you provide a route key,
and it will return the Route object. The route key is generally `<page-output-directory/page-identifier>`. Here are some examples:

```php
// Source file: _pages/index.md/index.blade.php
// Compiled file: _site/index.html
Routes::get('index')

// Source file: _posts/my-post.md
// Compiled file: _site/posts/my-post.html
Routes::get('posts/my-post')

// Source file: _docs/readme.md
// Compiled file: _site/docs/readme.html
Routes::get('docs/readme')
```

### Using the `x-link` component

When designing Blade layouts it can be useful to use the `x-link` component to automatically resolve relative links.

You can of course, use it just like a normal anchor tag like so:

```blade
<x-link href="index.html">Home</x-link>
```

But where it really shines is when you supply a route. This will then resolve the proper relative link, and format it to use pretty URLs if your site is configured to use them.

```blade
<x-link :href="Routes::get('index')">Home</x-link>
```

You can of course, also supply extra attributes like classes:

```blade
<x-link :href="Routes::get('index')" class="btn btn-primary">Home</x-link>
```


--- docs\architecture-concepts\dynamic-data-discovery.md ---

# Dynamic Data Discovery

[//]: # (Adds a pseudo-subtitle)
<h3 style="margin-top: 0px; margin-bottom: 20px;"><i>AKA: Front Matter & Filling in the Gaps</i></h3>


## Introduction

Hyde wants to allow developers to write less, and do more. This is also a major difference between HydePHP and JekyllRB.
Jekyll will only do what you _tell it to do_. Hyde, on the other hand, will try to do what you _want it to do_.

As with all other chapters in this category, you don't need to know about this to use Hyde -- that's the whole point!
However, if you're anything like me, you'll likely find this interesting to read about, even if you don't really need to know it.

Hyde makes great use of front matter in both Markdown and Blade files (it's true!). However, it can quickly get tedious
and quite frankly plain boring to have to write a bunch of front matter all the time. As Hyde wants you to focus on
your content, and not your markup, front matter is optional and Hyde will try to fill in the gaps for you.

If you're not happy with Hyde's generated data you can always override it by adding front matter to your files.


## How it Works

Now, to the fun part: getting into the nitty-gritty details of how Hyde does this!

To make things simple the dynamic data is created in a special stage where the page object is being created.
If you have not yet read the [page models chapter](page-models) you might want to do so now.
You might also want to read about the [autodiscovery lifecycle](autodiscovery) for some context as to when this happens.

### The factory pipeline, in short

After basic information about the page has been gathered, such as the source file information and the front matter,
the page model is run through a series of factories. These are just classes that work around the limited data
that is available at this point, and will assign the rich data needed to make your Hyde page awesome.

There are a few factory classes. The one we will be looking at here is the `HydePageDataFactory` class, which is
responsible for data applicable to all page models. Complex structures and data only relevant to some page types
have their own factories, making the code more modular and maintainable.


## In-depth overview of a page factory

Let's take a look at how Hyde will discover the title of a page as an example. Since this is something used by all pages,
this discovery is done in the `HydePageDataFactory` class.

### Factory data input

The factory gets one input, a `CoreDataObject` class. Think of this like a DTO (Data Transfer Object) that holds
immutable data known from the start of the page construction process. It also has all the information needed
to identify the page and its source file. Here's a simplified version of the class:

```php
class CoreDataObject
{
    public readonly FrontMatter $matter;
    public readonly Markdown|false $markdown;

    public readonly string $pageClass;
    public readonly string $identifier;
    public readonly string $sourcePath;
    public readonly string $outputPath;
    public readonly string $routeKey;
}
```

### Processing the known data

Now that we have the input we pass it to the factory, where a simple algorithm is used to find the best title for the page.

```php
private function findTitleForPage(): string
{
    return $this->matter('title')
        ?? $this->findTitleFromMarkdownHeadings()
        ?? Hyde::makeTitle(basename($this->identifier));
}
```

As you can see, we are using the null coalescing operator (`??`) to return the first non-null value. We always want the
user to be able to set any data explicitly, so we first check the front matter in all factory methods.

If no title is set in the matter the method will return null, and Hyde will try the next step which is to search the headings.
If that fails, the last step will generate a title from the file name. This ensures that no matter what, we always have a title.

### Injecting the data into the page

Once the data has been discovered, it is injected into the page object. This is rather unglamorous but is mentioned
here for completeness. It's pretty simple. The factory will always return an array of the computed data, where the keys
always match the property names on the page object, so we just need to loop over the array and set the properties.

```php
foreach ($data->toArray() as $key => $value) {
    $this->{$key} = $value;
}
```

And that's pretty much it! Hyde will do this for all the data it can discover, all so that you can focus on your content.


--- docs\architecture-concepts\extensions-api.md ---



--- docs\architecture-concepts\page-models.md ---


# The Hyde Page Models

## Introduction

The Hyde page models are an integral part of how HydePHP creates your static site. Each page in your site is represented
by a page model. These are simply PHP classes that in addition to holding both the source content and computed data
for your pages, also house instructions to Hyde on how to parse, process, and render the pages to static HTML.

In this article, you'll get a high-level overview of the page models, and some code examples to give you a look inside.


## The short version

#### Page models are classes that have two primary concerns:

1. They act as blueprints containing _static_ instructions for how to parse, process, and, render pages.
2. Each class _instance_ also holds the page source contents, as well as the computed data.

#### Other key points:

- HydePHP, at the time of writing, comes with five different page classes, one for each supported type.
- You don't construct page models yourself. HydePHP does it for you by the [autodiscovery process](autodiscovery).
- Page models are just PHP classes. You can extend them, and you can implement your own.


## The Page Model

To give you an idea of what a page model class looks like, here's a simplified version of the base `MarkdownPost` class,
Don't worry if you don't understand everything yet, we'll talk more about these parts later.

```php
class MarkdownPost extends BaseMarkdownPage
{
    public static string $sourceDirectory = '_posts';
    public static string $outputDirectory = 'posts';
    public static string $fileExtension = '.md';
    public static string $template = 'post';

    public string $identifier;
    public string $routeKey;
    public string $title;

    public FrontMatter $matter;
    public Markdown $markdown;
}
```

_Note that since Hyde pages are modular through class inheritance and traits, this example has been simplified and
edited to show all the relevant parts inlined into one class._


## Page Models as Blueprints

All page models have some static properties (that is, they belong to the class, not the instance) that are used as
blueprints, defining information for Hyde to know how to parse a file, and what data around it should be generated.

Let's again take the simplified `MarkdownPost` class as an example, this time only showing the static properties:

```php
class MarkdownPost extends BaseMarkdownPage
{
    public static string $sourceDirectory = '_posts';
    public static string $outputDirectory = 'posts';
    public static string $fileExtension = '.md';
    public static string $template = 'post';
}
```

#### What each property does

The properties should be self-explanatory, but here's a quick rundown to give some context on how they are used,
and how the paths relate to each other. So for the class above, Hyde will thanks to this blueprint, know to:
* Look for files in the `_posts` directory, with the `.md` extension
* Compile the page using the `post` Blade template
* Output the compiled page to the `_site/posts` directory


## Page Models as Data Containers

As mentioned above, each page model instance also holds the page source contents, as well as the computed data.

Let's again take the simplified `MarkdownPost` class as an example, this time only showing the instance properties:

```php
class MarkdownPost extends BaseMarkdownPage
{
    public string $identifier;
    public string $routeKey;
    public string $title;

    public FrontMatter $matter;
    public Markdown $markdown;
}
```

There are some more properties than shown here, for example, various metadata properties, but these are the most common
and important ones.

While the static data gives instructions to Hyde on how to process all pages of the type, the instance data tells Hyde
how to process a specific page. For example, the identifier property is used to uniquely identify the page, and
the routeKey property is used to generate the URL for the page.

The matter and markdown properties as I'm sure you can guess, hold the page's front matter and markdown content.
These can then also be processed by [page factories](dynamic-data-discovery) to generate the computed data like the
title property.


--- docs\architecture-concepts\the-hydekernel.md ---

# The HydeKernel

## Introduction

In the centre, or should I say _core_, of HydePHP is the HydeKernel. The kernel encapsulates a HydePHP project and
provides helpful methods for interacting with it. You can think of it as the heart of HydePHP, if you're a romantic.

The HydeKernel is so important that you have probably used it already. The main entry point for the HydePHP
API is the Hyde facade, which calls methods on the kernel.

```php
use Hyde\Hyde;
use Hyde\Foundation\HydeKernel;

Hyde::version(); // calls $HydeKernel->version()
```

The kernel is created very early on in the application lifecycle, in the `bootstrap.php` file, where it is also bound
as a singleton into the application service container.


## Accessing the kernel

The HydeKernel It is stored as a singleton in this class, and is bound into the
Laravel Application Service Container, and can be accessed in a few ways.

Commonly, you'll use the `Hyde` facade, but you can also use Dependency Injection
by type-hinting the `HydeKernel::class`, or use the `hyde()` function to get the Kernel.

The Kernel instance is constructed in `bootstrap.php`, and is available globally as `$hyde`.

Here are some examples of how you can call methods on the Kernel. All methods call the same method on the same instance, so it's just a matter of preference.

```php
use Hyde\Hyde;
use Hyde\Foundation\HydeKernel;

Hyde::version();
Hyde::kernel()->version();
HydeKernel::getInstance()->version();
app(HydeKernel::class)->version();
hyde()->version();
```


## The kernel lifecycle

Whenever we talk about the kernel being "booted" we are talking about the kernel's role in the autodiscovery process.

You can read all about it in the [Autodiscovery Documentation](autodiscovery).


## API Reference

Since the most common way to interact with the kernel is through the Hyde facade, we will use that for the examples.
But you could just as well chain the methods on the accessed kernel singleton instance if you wanted.

<section id="hyde-kernel-base-methods">

<!-- Start generated docs for Hyde\Foundation\HydeKernel -->
<!-- Generated by HydePHP DocGen script at 2023-03-11 11:09:45 in 2.53ms -->

#### `version()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::version(): string
```

#### `__construct()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
$hyde = new HydeKernel(string $basePath): void
```

#### `features()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::features(): Hyde\Facades\Features
```

#### `hasFeature()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::hasFeature(string $feature): bool
```

#### `toArray()`

Get the instance as an array.

```php
// torchlight! {"lineNumbers": false}
Hyde::toArray(): array<TKey, TValue>
```

<!-- End generated docs for Hyde\Foundation\HydeKernel -->

</section>

<section id="hyde-kernel-foundation-methods">

<!-- Start generated docs for Hyde\Foundation\Concerns\HandlesFoundationCollections -->
<!-- Generated by HydePHP DocGen script at 2023-03-11 11:14:55 in 0.06ms -->

#### `files()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::files(): \Hyde\Foundation\Kernel\FileCollection<string, \Hyde\Support\Filesystem\ProjectFile>
```

#### `pages()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::pages(): \Hyde\Foundation\Kernel\PageCollection<string, \Hyde\Pages\Concerns\HydePage>
```

#### `routes()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::routes(): \Hyde\Foundation\Kernel\RouteCollection<string, \Hyde\Support\Models\Route>
```

<!-- End generated docs for Hyde\Foundation\Concerns\HandlesFoundationCollections -->

</section>

<section id="hyde-kernel-string-methods">

<!-- Start generated docs for Hyde\Foundation\Concerns\ImplementsStringHelpers -->
<!-- Generated by HydePHP DocGen script at 2023-03-11 11:17:34 in 0.07ms -->

#### `makeTitle()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::makeTitle(string $value): string
```

#### `normalizeNewlines()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::normalizeNewlines(string $string): string
```

#### `stripNewlines()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::stripNewlines(string $string): string
```

#### `trimSlashes()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::trimSlashes(string $string): string
```

#### `markdown()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::markdown(string $text, bool $normalizeIndentation): Illuminate\Support\HtmlString
```

<!-- End generated docs for Hyde\Foundation\Concerns\ImplementsStringHelpers -->

</section>

<section id="hyde-kernel-hyperlink-methods">

<!-- Start generated docs for Hyde\Foundation\Concerns\ForwardsHyperlinks -->
<!-- Generated by HydePHP DocGen script at 2023-03-11 11:17:34 in 0.09ms -->

#### `formatLink()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::formatLink(string $destination): string
```

#### `relativeLink()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::relativeLink(string $destination): string
```

#### `mediaLink()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::mediaLink(string $destination, bool $validate): string
```

#### `asset()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::asset(string $name, bool $preferQualifiedUrl): string
```

#### `url()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::url(string $path): string
```

#### `hasSiteUrl()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::hasSiteUrl(): bool
```

<!-- End generated docs for Hyde\Foundation\Concerns\ForwardsHyperlinks -->

</section>

<section id="hyde-kernel-filesystem-methods">

<!-- Start generated docs for Hyde\Foundation\Concerns\ForwardsFilesystem -->
<!-- Generated by HydePHP DocGen script at 2023-03-11 11:17:34 in 0.10ms -->

#### `filesystem()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::filesystem(): Hyde\Foundation\Kernel\Filesystem
```

#### `path()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::path(string $path): string
```

#### `vendorPath()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::vendorPath(string $path, string $package): string
```

#### `mediaPath()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::mediaPath(string $path): string
```

#### `sitePath()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::sitePath(string $path): string
```

#### `siteMediaPath()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::siteMediaPath(string $path): string
```

#### `pathToAbsolute()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::pathToAbsolute(array|string $path): array|string
```

#### `pathToRelative()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::pathToRelative(string $path): string
```

<!-- End generated docs for Hyde\Foundation\Concerns\ForwardsFilesystem -->

</section>

<section id="hyde-kernel-kernel-methods">

<!-- Start generated docs for Hyde\Foundation\Concerns\ManagesHydeKernel -->
<!-- Generated by HydePHP DocGen script at 2023-03-11 11:17:34 in 0.12ms -->

#### `getInstance()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::getInstance(): Hyde\Foundation\HydeKernel
```

#### `setInstance()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::setInstance(Hyde\Foundation\HydeKernel $instance): void
```

#### `getBasePath()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::getBasePath(): string
```

#### `setBasePath()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::setBasePath(string $basePath): void
```

#### `getSourceRoot()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::getSourceRoot(): string
```

#### `setSourceRoot()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::setSourceRoot(string $sourceRoot): void
```

#### `getOutputDirectory()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::getOutputDirectory(): string
```

#### `setOutputDirectory()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::setOutputDirectory(string $outputDirectory): void
```

#### `getMediaDirectory()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::getMediaDirectory(): string
```

#### `setMediaDirectory()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::setMediaDirectory(string $mediaDirectory): void
```

#### `getMediaOutputDirectory()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::getMediaOutputDirectory(): string
```

<!-- End generated docs for Hyde\Foundation\Concerns\ManagesHydeKernel -->

</section>

<section id="hyde-kernel-extensions-methods">

<!-- Start generated docs for Hyde\Foundation\Concerns\ManagesExtensions -->
<!-- Generated by HydePHP DocGen script at 2023-03-11 11:17:34 in 0.12ms -->

#### `registerExtension()`

Register a HydePHP extension within the HydeKernel.

Typically, you would call this method in the register method of a service provider. If your package uses the standard Laravel (Composer) package discovery feature, the extension will automatically be enabled when the package is installed.

```php
// torchlight! {"lineNumbers": false}
Hyde::registerExtension(class-string&lt;\Hyde\Foundation\Concerns\HydeExtension&gt; $extension): void
```

#### `getExtension()`

Get the singleton instance of the specified extension.

```php
// torchlight! {"lineNumbers": false}
Hyde::getExtension(class-string&lt;T&gt; $extension): T
```

#### `hasExtension()`

Determine if the specified extension is registered.

```php
// torchlight! {"lineNumbers": false}
Hyde::hasExtension(class-string&lt;\Hyde\Foundation\Concerns\HydeExtension&gt; $extension): bool
```

#### `getExtensions()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::getExtensions(): array<\Hyde\Foundation\Concerns\HydeExtension>
```

#### `getRegisteredExtensions()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::getRegisteredExtensions(): array<class-string<\Hyde\Foundation\Concerns\HydeExtension>>
```

#### `getRegisteredPageClasses()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::getRegisteredPageClasses(): array<class-string<\Hyde\Pages\Concerns\HydePage>>
```

<!-- End generated docs for Hyde\Foundation\Concerns\ManagesExtensions -->

</section>

<section id="hyde-kernel-view-methods">

<!-- Start generated docs for Hyde\Foundation\Concerns\ManagesViewData -->
<!-- Generated by HydePHP DocGen script at 2023-03-11 11:17:34 in 0.06ms -->

#### `shareViewData()`

Share data for the page being rendered.

```php
// torchlight! {"lineNumbers": false}
Hyde::shareViewData(Hyde\Pages\Concerns\HydePage $page): void
```

#### `currentRouteKey()`

Get the route key for the page being rendered.

```php
// torchlight! {"lineNumbers": false}
Hyde::currentRouteKey(): string
```

#### `currentRoute()`

Get the route for the page being rendered.

```php
// torchlight! {"lineNumbers": false}
Hyde::currentRoute(): Hyde\Support\Models\Route
```

#### `currentPage()`

Get the page being rendered.

```php
// torchlight! {"lineNumbers": false}
Hyde::currentPage(): Hyde\Pages\Concerns\HydePage
```

<!-- End generated docs for Hyde\Foundation\Concerns\ManagesViewData -->

</section>

<section id="hyde-kernel-boot-methods">

<!-- Start generated docs for Hyde\Foundation\Concerns\BootsHydeKernel -->
<!-- Generated by HydePHP DocGen script at 2023-03-11 11:17:34 in 0.09ms -->

#### `isBooted()`

Determine if the Kernel has booted.

```php
// torchlight! {"lineNumbers": false}
Hyde::isBooted(): bool
```

#### `boot()`

Boot the Hyde Kernel and run the Auto-Discovery Process.

```php
// torchlight! {"lineNumbers": false}
Hyde::boot(): void
```

#### `booting()`

Register a new boot listener.

Your callback will be called before the kernel is booted. You can use this to register your own routes, pages, etc. The kernel instance will be passed to your callback.

```php
// torchlight! {"lineNumbers": false}
/** @param callable(\Hyde\Foundation\HydeKernel): void $callback */
Hyde::booting(callable(\Hyde\Foundation\HydeKernel): void): void
```

#### `booted()`

Register a new &quot;booted&quot; listener.

Your callback will be called after the kernel is booted. You can use this to run any logic after discovery has completed. The kernel instance will be passed to your callback.

```php
// torchlight! {"lineNumbers": false}
/** @param callable(\Hyde\Foundation\HydeKernel): void $callback */
Hyde::booted(callable(\Hyde\Foundation\HydeKernel): void): void
```

<!-- End generated docs for Hyde\Foundation\Concerns\BootsHydeKernel -->

</section>


--- docs\creating-content\blog-posts.md ---



--- docs\creating-content\compile-and-deploy.md ---



## Deploying your site

One of the things that make static sites so enjoyable to work with is how easy it is to deploy them to the web.
This list is not exhaustive, but gives you a general idea of the most common ways to deploy your site.
If you have ideas to add to the documentation, please send a pull request!

### General deployment

In essence, all you need to do is copy the contents of the `_site` directory to a web server, and you're done.

Once the site is compiled there is nothing to configure or worry about.

### FTP and File Managers

If you have a conventional web host, you can use `FTP`/`SFTP`/`FTPS` to upload your compiled site files to the web server.
Some web hosting services also have web based file managers.

To deploy your site using any of these methods, all you need to do is upload the entire contents of your `_site`
directory to the web server's public document root, which is usually the `public_html`, `htdocs`, or `www` directory.

### GitHub Pages - Manually

GitHub Pages is a free service that allows you to host your static site on the web.

In general, push the entire contents of your `_site` directory to the `gh-pages` branch of your repository,
or the `docs/` directory on your main branch, depending on how you set it up.

Please see the [GitHub Pages documentation](https://help.github.com/pages/getting-started-with-github-pages/) for more information.

### GitHub Pages - CI/CD

Hyde works amazing with GitHub Pages and GitHub Actions and the entire build and deploy process can be automated.

- We have a great blog post on how to do this, [Automate HydePHP sites using GitHub Actions and GitHub Pages](https://hydephp.com/posts/github-actions-deployment).

- You can also copy our sample [GitHub Actions Workflow.yml file](https://github.com/hyde-staging/ci-demo/blob/master/.github/workflows/main.yml).

By the way, HydePHP.com is hosted on GitHub Pages, and the site is compiled in a GitHub Action workflow that compiles and
deploys the site automatically when the source is updated using [this GitHub workflow](https://github.com/hydephp/hydephp.com/blob/master/.github/workflows/build.yml).


--- docs\creating-content\documentation-pages.md ---



--- docs\creating-content\managing-assets.md ---



--- docs\creating-content\static-pages.md ---



--- docs\digging-deeper\advanced-customization.md ---



--- docs\digging-deeper\advanced-markdown.md ---


# Advanced Markdown

## Introduction

Since HydePHP makes heavy use of Markdown, there are some extra features and helpers created just for Hyde to make using Markdown even easier and more powerful!


## Using Blade in Markdown

A special feature in Hyde, is that you can use [Laravel Blade](https://laravel.com/docs/10.x/blade) in Markdown files!

To use Blade in your Markdown files, simply use the Blade shortcode directive, followed by your desired Blade string.

### Standard syntax

```markdown
 [Blade]: {{ "Hello World!" }} // Will render: 'Hello World!'
```

### Blade includes

Only single-line shortcode directives are supported. If you need to use multi-line Blade code, use an `@include`
directive to render a more complex Blade template. You can pass data to includes by specifying an array to the second argument.

```markdown
 [Blade]: @include("hello-world")
 [Blade]: @include("hello", ["name" => "World"])
```

### Enabling Blade-supported Markdown

The feature is disabled by default since it allows arbitrary PHP to run, which could be a security risk, depending on your setup.
However, if your Markdown is trusted, and you know it's safe, you can enable it in the `config/markdown.php` file.

```php
// filepath: config/markdown.php
'enable_blade' => true,
```

### Limitations

All shortcodes must be the first word on a new line, and only single-line shortcodes are supported.


## Coloured Blockquotes

The HydePHP Markdown converter also supports some extra directives and features. One of them being four different
coloured blockquotes. Simply append the desired colour after the initial `>` character.

```markdown
‎> Normal Blockquote
‎>info Info Blockquote
‎>warning Warning Blockquote
‎>danger Danger Blockquote
‎>success Success Blockquote
```

> Normal Blockquote
>info Info Blockquote
>warning Warning Blockquote
>danger Danger Blockquote
>success Success Blockquote

### Customizations

You can easily customize these styles too by adding and editing the following in your `resources/app.css` file, and then recompiling your site styles.
The code examples here use the Tailwind `@apply` directives, but you could also use `border-color: something;` just as well.

```css
/* filepath resources/app.css

/* Markdown Features */

.prose blockquote.info {
    @apply border-blue-500;
}

.prose blockquote.success {
    @apply border-green-500;
}

.prose blockquote.warning {
    @apply border-amber-500;
}

.prose blockquote.danger {
    @apply border-red-600;
}
```

### Markdown usage

The coloured blockquotes also support inline Markdown, just like normal blockquotes.

```markdown
‎>info Formatting is **supported**!
```

### Limitations

Note that these currently do not support multi-line blockquotes.


## Code block filepaths

When browsing these documentation pages you may have noticed a label in the top right corner of code blocks specifying the file path.
These are also created by using a custom Hyde feature that turns code comments into automatic code blocks.

### Usage

Simply add a code comment with the path in the **first line** of a fenced code block like so:

````markdown
// Filepath: _docs/advanced-markdown.md
```php
‎// Filepath: hello-world.php

echo 'Hello World!';
```
````

Which becomes:

```php
// Filepath: hello-world.php

echo 'Hello World!';
```

### Alternative syntax

The syntax is rather forgiving, by design, and supports using both `//` and `#` for comments.
The colon is also optional, and the 'filepath' string is case-insensitive. So the following is also perfectly valid:

````markdown
```js
‎// filepath hello.js
console.log('Hello World!');
```
````

If you have a newline after the filepath, like in the first example, it will be removed so your code stays readable.

### Advanced usage

If you have enabled HTML in Markdown by setting the `allow_html` option to true in your `config/markdown.php` file,
anything within the path label will be rendered as HTML. This means you can add links, or even images to the label.

````markdown
// Filepath: <a href="https://github.com/hydephp/develop/blob/master/docs/digging-deeper/advanced-markdown.md" rel="nofollow noopener" target="_blank">View file on Github</a>
```markdown
‎// Filepath: <a href="https://github.com">View file on Github</a>
```
````

### Limitations

The filepaths are hidden on mobile devices using CSS to prevent them from overlapping with the code block.


## Configuration

### Full configuration reference

All Markdown-related configuration options are in the `config/markdown.php` file.
You can find the full reference on the [Customization](customization#markdown-configuration) page.

### Raw HTML Tags

To convert Markdown, HydePHP uses the GitHub Flavored Markdown extension, which strips out potentially unsafe HTML.
If you want to allow all arbitrary HTML tags, and understand the risks involved, you can enable all HTML tags by setting
the `allow_html` option to `true` in your `config/markdown.php` file.

```php
// filepath: config/markdown.php
'allow_html' => true,
```

This will add and configure the `DisallowedRawHtml` CommonMark extension so that no HTML tags are stripped out.

### Tailwind Typography Prose Classes

HydePHP uses the [Tailwind Typography](https://tailwindcss.com/docs/typography-plugin) to style rendered Markdown.
We do this by adding the `.prose` CSS class to the HTML elements containing the rendered Markdown, using the built-in Blade components.

You can easily edit these classes, for example if you want to customize the prose colours, in the `config/markdown.php` file.

```php
// filepath: config/markdown.php
'prose_classes' => 'prose dark:prose-invert', // [tl! remove]
'prose_classes' => 'prose dark:prose-invert prose-img:inline', // [tl! add]
```

Please note that if you add any new classes, you may need to recompile your CSS file.


--- docs\digging-deeper\collections.md ---



--- docs\digging-deeper\customization.md ---



--- docs\digging-deeper\troubleshooting.md ---



--- docs\digging-deeper\updating-hyde.md ---


# Updating Hyde Projects

This guide will help you update your HydePHP project to the latest version.


## Before you start

When updating an existing installation, first ensure that you have a backup of your project in case anything goes wrong.
The recommended way to do this is to use Git as that allows you to smoothly roll back any changes.


## Methods

### Which method?

Depending on how you installed Hyde, there are a few different ways to update it.

We have a few methods documented here. The [Git method](#using-git) is recommended as it is the easiest and safest way to
update your project. If you are not using Git, you can still update your project using any of the [manual methods](#manual-update).

Regardless of the method you use, make sure you follow the [post-update instructions](#post-update-instructions) at the end.

### Using Git

First, make sure you have a remote set up for the base project repository.

```bash
git remote add upstream https://github.com/hydephp/hyde.git
```

Then pull the latest release from the upstream repository.

```bash
git pull upstream master
```

After this, you should update your composer dependencies:

```bash
composer update
```

Next, follow the post-update instructions.

### Manual Update

If you are not using Git, you can still update your project. This is a bit more involved, but it is still possible.

1. First, you will need to download the latest release archive from the [releases page](https://github.com/hydephp/hyde/releases).
2. Then extract the archive, and copy the contents into your project directory.

Since this may overwrite modified files, it may be safer to use the [hard update](#hard-update) method.

### Hard Update

If you are having trouble updating your project, you can try a hard update. In short, this approach consists of creating
a brand new project and copying over only your source and resource files. If you do not want to use Git, this may be
the safest option as you won't be overriding any of your existing files.

If you have changed any other files, for example in the App directory, you will need to update those files manually as well.
The same goes if you have created any custom Blade components or have modified Hyde ones.

**Here is an example CLI workflow, but you can do the same using a graphical file manager.**

```bash
mv my-project my-project-old
composer create-project hyde/hyde my-project

cp -r my-old-project/_pages my-project/content/_pages
cp -r my-old-project/_posts my-project/content/_posts
cp -r my-old-project/_media my-project/content/_media
cp -r my-old-project/_docs my-project/content/_docs
cp -r my-old-project/config my-project/config
```

Next, follow the post-update instructions. After verifying that everything is working, you can delete the old project directory.


## Post-update instructions

After updating Hyde you should update your config and resource files. This is where things can get a tiny bit dangerous
as existing files may be overwritten. If you are using Git, you can easily take care of any merge conflicts that arise.

First, ensure that your dependencies are up to date. If you have already done this, you can skip this step.

```bash
composer update
```

Then, update your config files. This is the hardest part, as you may need to manually copy in your own changes.

```bash
php hyde publish:configs
```

If you have published any of the included Blade components you will need to re-publish them.

```bash
php hyde publish:views layouts
php hyde publish:views components
```

Next, recompile your assets, if you are not using the built-in assets.

```bash
npm install
npm run dev/prod
```

Finally, you can rebuild your site.

```bash
php hyde build
```


--- docs\extensions\extensions.md ---


# Extensions & Integrations

## HydePHP - Extensible by design

HydePHP is designed to be extensible, and comes with a number of built-in extensions and integrations,
as well as support for third-party extensions and integrations.

## First party extensions & integrations

### Realtime Compiler

The Hyde Realtime Compiler is included with Hyde installations and is what powers the `php hyde serve` command.
- Learn more about the [Realtime Compiler](realtime-compiler) in the documentation.

## Integrations with third-party tools

### Torchlight

Torchlight is an amazing API for syntax highlighting, and is supported natively by HydePHP.
- Learn more about [Torchlight](third-party-integrations#torchlight) in the documentation.

## Contribute

Have an idea for an extension or integration? Let me know! I'd love to hear from you. Get in touch on
[GitHub](https://github.com/hydephp/hyde) or send me a DM on [Twitter](https://twitter.com/CodeWithCaen).
You may also want to look at the [Extension API](extensions-api) documentation to learn how to create extensions.

--- docs\extensions\realtime-compiler.md ---


# Realtime Compiler

The Hyde Realtime Compiler is included with Hyde installations and is what powers the `php hyde serve` command,
allowing you to preview your static site on a local development server without having to rebuild the site.

### Usage

To start the server, run the following command from a terminal in your project directory:

```bash
php hyde serve
```

This will start a local development server at `http://localhost:8080`

>warning Please note that the server is designed for local development, and should not be used on a public network.

### Configuration

The server can be configured in the `config/hyde.php` file to change the port, host, and to customize its features.

```php
// filepath config/hyde.php

'server' => [
    'port' => env('SERVER_PORT', 8080),
    'host' => env('SERVER_HOST', 'localhost'),
    'save_preview' => true,
],
```

### Live dashboard

#### Usage

The realtime compiler comes with a live dashboard that you can access at `http://localhost:8080/dashboard`.

From here, you can visually interact with your site content, including creating new pages and posts.

The live dashboard is not saved to your static site, and is only available through the development server.

#### Configuration

The dashboard can be customized, and disabled, in the `config/hyde.php` file.

```php
// filepath config/hyde.php

'server' => [
    'dashboard' => [
        'enabled' => env('SERVER_DASHBOARD', true),
        'interactive' => true,
        'tips' => true,
    ],
],
```

_The dashboard was added in Realtime Compiler v3.0.0 (March 2023), with interactive features added in v3.1.0 (October 2023)_

### Live edit

#### Usage

The live edit feature allows you to quickly edit Markdown-based pages (posts, docs, and pages) directly in the browser.

To enter the live editor, simply double-click on the article you want to edit, and it will be replaced with a text editor.
When you're done, click the save button to save the changes to the page's source file.

#### Shortcuts

The live editor supports the following keyboard shortcuts:
- `Ctrl + E` - Enter/Exit editor
- `Ctrl + S` - Save changes
- `esc` - Exit editor if active

#### Configuration

The live editor can be disabled in the `config/hyde.php` file.
The live editor plugin code will not be saved to your static site.

```php
// filepath config/hyde.php

'server' => [
    'live_edit' => env('SERVER_LIVE_EDIT', true),
],
```

_The live editor was added in Hyde Realtime Compiler Server v3.2.0 (November 2023)_

### Source code

- **GitHub**: [hydephp/realtime-compiler](https://github.com/hydephp/realtime-compiler)
- **Packagist**: [hydephp/realtime-compiler](https://packagist.org/packages/hyde/realtime-compiler)


--- docs\extensions\third-party-integrations.md ---


# Integrations with third-party tools

## Torchlight

Torchlight is an amazing API for syntax highlighting, and is used by this site. I cannot recommend it highly enough,
especially for documentation sites and code-heavy blogs! As such, HydePHP has built-in support for Torchlight,
which is automatically enabled once you add an API token to your `.env` file. Nothing else needs to be done!

### Getting started

To get started you need an API token which you can get at [Torchlight.dev](https://torchlight.dev/).
It is entirely free for personal and open source projects, as seen on their [pricing page](https://torchlight.dev/#pricing).

When you have an API token, set it in the `.env` file in the root directory of your project.
Once a token is set, Hyde will automatically enable the CommonMark extension.

```env
TORCHLIGHT_TOKEN=torch_<your-api-token>
```

### Attribution and configuration

Note that for the free plan you need to provide an attribution link. Thankfully Hyde injects a customizable link
automatically to all pages that use Torchlight. You can of course disable and customize this in the `config/torchlight.php` file.

```php
'attribution' => [
    'enabled' => true,
    'markdown' => 'Syntax highlighting by <a href="https://torchlight.dev/" rel="noopener nofollow">Torchlight.dev</a>',
],
```

Don't have this file? Run `php hyde vendor:publish` to publish it.



--- docs\getting-started\console-commands.md ---



--- docs\getting-started\core-concepts.md ---



--- docs\getting-started\front-matter.md ---


## Markdown comes here

Lorem ipsum dolor sit amet, etc.
```

### Front Matter in Blade

HydePHP has experimental support for creating front-matter in Blade templates, called BladeMatter.

The actual syntax does not use YAML; but instead PHP. However, the parsed end result is the same. Please note that
BladeMatter currently does not support multidimensional arrays or multi-line directives as the data is statically parsed.

To create BladeMatter, you simply use the default Laravel Blade `@php` directive to declare a variable in the template.

```blade
@php($title = 'BladeMatter Demo')
```

It will then be available through the global `$page` variable, `$page->matter('title')`.
Hyde will of course also use the data for contextual autoconfiguration in the same way it would with Markdown and use the value as the page title.

Another idea is to use `@php($navigation = ['hidden' => true])` if you want to hide a page from the navigation. The opportunities are limitless!


--- docs\getting-started\quickstart.md ---


# Quickstart Guide

## Installing HydePHP using Composer

The recommended method of installing Hyde is using Composer, which installs the required dependencies on a per-project basis.

```bash
// torchlight! {"lineNumbers": false}
composer create-project hyde/hyde
```

### Requirements

Hyde is based on [Laravel 10](https://laravel.com/docs/10.x/releases)
which requires a minimum PHP version of 8.1.
You should also have [Composer](https://getcomposer.org/) installed.

To use some features like [compiling your own assets](managing-assets)
you also need NodeJS and NPM.


## Using the Hyde CLI

The main way to interact with Hyde is through the [HydeCLI](console-commands), a Laravel Artisan-based command-line interface. Learn more about the HydeCLI in the [console commands](console-commands) documentation.


## Starting a development server

To make previewing your site a breeze you can use the realtime compiler, which builds your pages on the fly.

```bash
php hyde serve
```
Simply run the serve command, and you will be able to preview your site at [http://localhost:8080](http://localhost:8080).


## Creating content

### Directory structure

Creating content with Hyde is easy! Simply place source files in one of the source directories,
and Hyde will automatically discover, parse, and compile them to static HTML.
The directory and file extension of a source file will determine how HydePHP parses and compiles it.
Please see the [directory structure](core-concepts#directory-structure) section for more information.

### Scaffolding files

You can scaffold blog post files using the `php hyde make:post` command which automatically creates the front matter, based on your input selections.
You can also scaffold pages with the `php hyde make:page` command.

```bash
php hyde make:post
php hyde make:page
```

### Compiling to static HTML

Now that you have some amazing content, you'll want to compile your site into static HTML. Thankfully, this is as easy as executing the `build` command, after which your compiled site is stored in the `_site` directory.

```bash
php hyde build
```

When building the site, Hyde will scan your source directories for files and compile them into static HTML using the appropriate layout depending
on what kind of page it is. You don't have to worry about routing as Hyde takes care of everything, including creating navigation menus!

### Managing assets

Hyde comes bundled with a precompiled and minified `app.css` file, containing all the Tailwind you need for the default views meaning that you don't even need to use NPM. However, Hyde is already configured to use Laravel Mix to compile your assets if you feel like there's a need to build the assets yourself. See more on the [Managing Assets](managing-assets) page.

### Deploying your site

You are now ready to show your site to the world! Simply copy the `_site` directory to your web server's document root, and you're ready to go.

You can even use GitHub Pages to host your site for free. That's what the Hyde website does, using an Actions CI workflow that automatically builds and deploys this site.


## Further reading

Here's some ideas of what to read next:

- [Architecture Concepts & Directory Structure](core-concepts)
- [Console Commands with the HydeCLI](console-commands)
- [Creating Blog Posts](blog-posts)


--- docs\index.md ---

# Elegant and Powerful Static Site Generator

<style>.images-inline img { display: inline; margin: 4px 2px;}</style>

[![Latest Version on Packagist](https://img.shields.io/packagist/v/hyde/framework?include_prereleases)](https://packagist.org/packages/hyde/framework)
[![Total Downloads on Packagist](https://img.shields.io/packagist/dt/hyde/framework)](https://packagist.org/packages/hyde/framework)
[![Test Coverage](https://codecov.io/gh/hydephp/develop/branch/master/graph/badge.svg?token=G6N2161TOT)](https://codecov.io/gh/hydephp/develop)
[![Scrutinizer Code Quality](https://scrutinizer-ci.com/g/hydephp/develop/badges/quality-score.png?b=master)](https://scrutinizer-ci.com/g/hydephp/develop/?branch=master)
[![Psalm Type Coverage](https://shepherd.dev/github/hydephp/develop/coverage.svg)](https://shepherd.dev/github/hydephp/develop)
![License MIT](https://img.shields.io/github/license/hydephp/hyde)
{.images-inline .not-prose}


## About HydePHP

HydePHP is a new Static Site Builder focused on writing content, not markup. With Hyde, it is easy to create static
websites, blogs, and documentation pages using Markdown and (optionally) Laravel's Blade.

Operated entirely through the command-line, HydePHP provides developers with a fast and efficient way to create high-quality websites with ease.
Unlike traditional web development frameworks, sites compiled with HydePHP don't require any server to run,
making it an ideal choice for building lightweight and fast-loading websites.

Compared with other static site builders, Hyde is blazingly fast and seriously simple to get started with, yet it has the
full power of Laravel waiting for you when you need it, as Hyde is powered by Laravel Zero, a stripped-down version of
the robust and popular Laravel Framework, optimized for console applications.

Hyde makes creating websites easy and fun by taking care of the boring stuff, like routing, writing boilerplate, and
endless configuration. Instead, when you create a new Hyde project, everything you need to get started is already there
-- including precompiled TailwindCSS, well-crafted Blade templates, and easy-to-use asset management.

Hyde was inspired by JekyllRB and is designed for developers who are comfortable writing posts in Markdown, and it requires
virtually no configuration out of the box as it favours convention over configuration and is preconfigured with sensible defaults.


## Installation

HydePHP is a command-line interface (CLI) application that is installed on a per-project basis.

To use HydePHP, your system must have PHP version 8.1 or later installed, along with Composer, and access to a terminal.

The recommended method of installation is using Composer.

```bash
composer create-project hyde/hyde
```

Once installed, you can access the HydeCLI from the project root using the `hyde` command.

```bash
php hyde info
```


## Usage

Creating static websites with HydePHP is incredibly easy. First you need some content. You can just drop Markdown files
in any of the source directories, or let Hyde scaffold the files for you using one of the many commands.

```bash
php hyde make:post "My First Post"
php hyde make:page "About Me"
```

Once you have some content, you can run the build command to compile the content into beautiful static HTML.

```bash
php hyde build
```

And that's it, your amazing website is ready to be shared with the world!

### To learn more, head over to the [quickstart page](quickstart).


--- docs\README.md ---


# Hyde Documentation

This is the source for the HydePHP Documentation. Updates here are automatically propagated to the [HydePHP.com](https://github.com/hydephp/hydephp.com) website.

This document is not propagated to the website. It is only for the GitHub development repository.


--- docs\redirects\directory-structure.md ---


<meta http-equiv="refresh" content="0;url=architecture-concepts#directory-structure" />

Redirecting you to [architecture-concepts#directory-structure](architecture-concepts#directory-structure)

<!-- Note to self, if we need a lot of these in the future it may make more sense to put them in a CI that loads redirects from a config -->


--- docs\redirects\getting-started.md ---


<meta http-equiv="refresh" content="0;url=quickstart" />

Redirecting you to [quickstart](quickstart)

<!-- Note to self, if we need a lot of these in the future it may make more sense to put them in a CI that loads redirects from a config -->


--- docs\redirects\installation.md ---


<meta http-equiv="refresh" content="0;url=quickstart" />

Redirecting you to [quickstart](quickstart)

<!-- Note to self, if we need a lot of these in the future it may make more sense to put them in a CI that loads redirects from a config -->


--- docs\_data\partials\hyde-pages-api\base-markdown-page-methods.md ---

<section id="base-markdown-page-methods">

<!-- Start generated docs for Hyde\Pages\Concerns\BaseMarkdownPage -->
<!-- Generated by HydePHP DocGen script at 2023-03-10 18:22:36 in 0.67ms -->

#### `make()`

Create a new page instance. Static alias for the constructor.

```php
// torchlight! {"lineNumbers": false}
BaseMarkdownPage::make(string $identifier, Hyde\Markdown\Models\FrontMatter|array $matter, Hyde\Markdown\Models\Markdown|string $markdown): static
```

#### `__construct()`

Construct a new page instance.

```php
// torchlight! {"lineNumbers": false}
$page = new BaseMarkdownPage(string $identifier, Hyde\Markdown\Models\FrontMatter|array $matter, Hyde\Markdown\Models\Markdown|string $markdown): void
```

#### `markdown()`

Return the document&#039;s Markdown object.

```php
// torchlight! {"lineNumbers": false}
$page->markdown(): Hyde\Markdown\Models\Markdown
```

#### `compile()`

Compile the page into static HTML.

```php
// torchlight! {"lineNumbers": false}
$page->compile(): string // The compiled HTML for the page.
```

#### `save()`

Save the Markdown page object to disk by compiling the front matter array to YAML and writing the body to the file.

```php
// torchlight! {"lineNumbers": false}
$page->save(): $this
```

<!-- End generated docs for Hyde\Pages\Concerns\BaseMarkdownPage -->

</section>


--- docs\_data\partials\hyde-pages-api\blade-page-methods.md ---

<section id="blade-page-methods">

<!-- Start generated docs for Hyde\Pages\BladePage -->
<!-- Generated by HydePHP DocGen script at 2023-03-10 20:46:42 in 0.31ms -->

#### `__construct()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
/** @param string $identifier The identifier, which also serves as the view key. */
$page = new BladePage(string $identifier, Hyde\Markdown\Models\FrontMatter|array $matter): void
```

#### `getBladeView()`

Get the Blade template/view key for the page.

```php
// torchlight! {"lineNumbers": false}
$page->getBladeView(): string
```

#### `compile()`

Compile the page into static HTML.

```php
// torchlight! {"lineNumbers": false}
$page->compile(): string // The compiled HTML for the page.
```

<!-- End generated docs for Hyde\Pages\BladePage -->

</section>


--- docs\_data\partials\hyde-pages-api\documentation-page-methods.md ---

<section id="documentation-page-methods">

<!-- Start generated docs for Hyde\Pages\DocumentationPage -->
<!-- Generated by HydePHP DocGen script at 2023-03-10 20:56:21 in 0.38ms -->

#### `home()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
DocumentationPage::home(): Hyde\Support\Models\Route
```

#### `homeRouteName()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
DocumentationPage::homeRouteName(): string
```

#### `hasTableOfContents()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
DocumentationPage::hasTableOfContents(): bool
```

#### `getOnlineSourcePath()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
$page->getOnlineSourcePath(): string|false
```

#### `getTableOfContents()`

Generate Table of Contents as HTML from a Markdown document body.

```php
// torchlight! {"lineNumbers": false}
$page->getTableOfContents(): string
```

#### `getRouteKey()`

Get the route key for the page.

If flattened outputs are enabled, this will use the identifier basename so nested pages are flattened.

```php
// torchlight! {"lineNumbers": false}
$page->getRouteKey(): string
```

#### `getOutputPath()`

Get the path where the compiled page will be saved.

If flattened outputs are enabled, this will use the identifier basename so nested pages are flattened.

```php
// torchlight! {"lineNumbers": false}
$page->getOutputPath(): string
```

<!-- End generated docs for Hyde\Pages\DocumentationPage -->

</section>


--- docs\_data\partials\hyde-pages-api\html-page-methods.md ---

<section id="html-page-methods">

<!-- Start generated docs for Hyde\Pages\HtmlPage -->
<!-- Generated by HydePHP DocGen script at 2023-03-10 20:56:21 in 1.08ms -->

#### `contents()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
$page->contents(): string
```

#### `compile()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
$page->compile(): string
```

#### `getBladeView()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
$page->getBladeView(): string
```

<!-- End generated docs for Hyde\Pages\HtmlPage -->

</section>


--- docs\_data\partials\hyde-pages-api\hyde-kernel-base-methods.md ---

<section id="hyde-kernel-base-methods">

<!-- Start generated docs for Hyde\Foundation\HydeKernel -->
<!-- Generated by HydePHP DocGen script at 2023-03-11 11:09:45 in 2.53ms -->

#### `version()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::version(): string
```

#### `__construct()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
$hyde = new HydeKernel(string $basePath): void
```

#### `features()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::features(): Hyde\Facades\Features
```

#### `hasFeature()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::hasFeature(string $feature): bool
```

#### `toArray()`

Get the instance as an array.

```php
// torchlight! {"lineNumbers": false}
Hyde::toArray(): array<TKey, TValue>
```

<!-- End generated docs for Hyde\Foundation\HydeKernel -->

</section>


--- docs\_data\partials\hyde-pages-api\hyde-kernel-boot-methods.md ---

<section id="hyde-kernel-boot-methods">

<!-- Start generated docs for Hyde\Foundation\Concerns\BootsHydeKernel -->
<!-- Generated by HydePHP DocGen script at 2023-03-11 11:17:34 in 0.09ms -->

#### `isBooted()`

Determine if the Kernel has booted.

```php
// torchlight! {"lineNumbers": false}
Hyde::isBooted(): bool
```

#### `boot()`

Boot the Hyde Kernel and run the Auto-Discovery Process.

```php
// torchlight! {"lineNumbers": false}
Hyde::boot(): void
```

#### `booting()`

Register a new boot listener.

Your callback will be called before the kernel is booted. You can use this to register your own routes, pages, etc. The kernel instance will be passed to your callback.

```php
// torchlight! {"lineNumbers": false}
/** @param callable(\Hyde\Foundation\HydeKernel): void $callback */
Hyde::booting(callable(\Hyde\Foundation\HydeKernel): void): void
```

#### `booted()`

Register a new &quot;booted&quot; listener.

Your callback will be called after the kernel is booted. You can use this to run any logic after discovery has completed. The kernel instance will be passed to your callback.

```php
// torchlight! {"lineNumbers": false}
/** @param callable(\Hyde\Foundation\HydeKernel): void $callback */
Hyde::booted(callable(\Hyde\Foundation\HydeKernel): void): void
```

<!-- End generated docs for Hyde\Foundation\Concerns\BootsHydeKernel -->

</section>


--- docs\_data\partials\hyde-pages-api\hyde-kernel-extensions-methods.md ---

<section id="hyde-kernel-extensions-methods">

<!-- Start generated docs for Hyde\Foundation\Concerns\ManagesExtensions -->
<!-- Generated by HydePHP DocGen script at 2023-03-11 11:17:34 in 0.12ms -->

#### `registerExtension()`

Register a HydePHP extension within the HydeKernel.

Typically, you would call this method in the register method of a service provider. If your package uses the standard Laravel (Composer) package discovery feature, the extension will automatically be enabled when the package is installed.

```php
// torchlight! {"lineNumbers": false}
Hyde::registerExtension(class-string&lt;\Hyde\Foundation\Concerns\HydeExtension&gt; $extension): void
```

#### `getExtension()`

Get the singleton instance of the specified extension.

```php
// torchlight! {"lineNumbers": false}
Hyde::getExtension(class-string&lt;T&gt; $extension): T
```

#### `hasExtension()`

Determine if the specified extension is registered.

```php
// torchlight! {"lineNumbers": false}
Hyde::hasExtension(class-string&lt;\Hyde\Foundation\Concerns\HydeExtension&gt; $extension): bool
```

#### `getExtensions()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::getExtensions(): array<\Hyde\Foundation\Concerns\HydeExtension>
```

#### `getRegisteredExtensions()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::getRegisteredExtensions(): array<class-string<\Hyde\Foundation\Concerns\HydeExtension>>
```

#### `getRegisteredPageClasses()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::getRegisteredPageClasses(): array<class-string<\Hyde\Pages\Concerns\HydePage>>
```

<!-- End generated docs for Hyde\Foundation\Concerns\ManagesExtensions -->

</section>


--- docs\_data\partials\hyde-pages-api\hyde-kernel-filesystem-methods.md ---

<section id="hyde-kernel-filesystem-methods">

<!-- Start generated docs for Hyde\Foundation\Concerns\ForwardsFilesystem -->
<!-- Generated by HydePHP DocGen script at 2023-03-11 11:17:34 in 0.10ms -->

#### `filesystem()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::filesystem(): Hyde\Foundation\Kernel\Filesystem
```

#### `path()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::path(string $path): string
```

#### `vendorPath()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::vendorPath(string $path, string $package): string
```

#### `mediaPath()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::mediaPath(string $path): string
```

#### `sitePath()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::sitePath(string $path): string
```

#### `siteMediaPath()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::siteMediaPath(string $path): string
```

#### `pathToAbsolute()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::pathToAbsolute(array|string $path): array|string
```

#### `pathToRelative()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::pathToRelative(string $path): string
```

<!-- End generated docs for Hyde\Foundation\Concerns\ForwardsFilesystem -->

</section>


--- docs\_data\partials\hyde-pages-api\hyde-kernel-foundation-methods.md ---

<section id="hyde-kernel-foundation-methods">

<!-- Start generated docs for Hyde\Foundation\Concerns\HandlesFoundationCollections -->
<!-- Generated by HydePHP DocGen script at 2023-03-11 11:14:55 in 0.06ms -->

#### `files()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::files(): \Hyde\Foundation\Kernel\FileCollection<string, \Hyde\Support\Filesystem\ProjectFile>
```

#### `pages()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::pages(): \Hyde\Foundation\Kernel\PageCollection<string, \Hyde\Pages\Concerns\HydePage>
```

#### `routes()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::routes(): \Hyde\Foundation\Kernel\RouteCollection<string, \Hyde\Support\Models\Route>
```

<!-- End generated docs for Hyde\Foundation\Concerns\HandlesFoundationCollections -->

</section>


--- docs\_data\partials\hyde-pages-api\hyde-kernel-hyperlink-methods.md ---

<section id="hyde-kernel-hyperlink-methods">

<!-- Start generated docs for Hyde\Foundation\Concerns\ForwardsHyperlinks -->
<!-- Generated by HydePHP DocGen script at 2023-03-11 11:17:34 in 0.09ms -->

#### `formatLink()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::formatLink(string $destination): string
```

#### `relativeLink()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::relativeLink(string $destination): string
```

#### `mediaLink()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::mediaLink(string $destination, bool $validate): string
```

#### `asset()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::asset(string $name, bool $preferQualifiedUrl): string
```

#### `url()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::url(string $path): string
```

#### `hasSiteUrl()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::hasSiteUrl(): bool
```

<!-- End generated docs for Hyde\Foundation\Concerns\ForwardsHyperlinks -->

</section>


--- docs\_data\partials\hyde-pages-api\hyde-kernel-kernel-methods.md ---

<section id="hyde-kernel-kernel-methods">

<!-- Start generated docs for Hyde\Foundation\Concerns\ManagesHydeKernel -->
<!-- Generated by HydePHP DocGen script at 2023-03-11 11:17:34 in 0.12ms -->

#### `getInstance()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::getInstance(): Hyde\Foundation\HydeKernel
```

#### `setInstance()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::setInstance(Hyde\Foundation\HydeKernel $instance): void
```

#### `getBasePath()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::getBasePath(): string
```

#### `setBasePath()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::setBasePath(string $basePath): void
```

#### `getSourceRoot()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::getSourceRoot(): string
```

#### `setSourceRoot()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::setSourceRoot(string $sourceRoot): void
```

#### `getOutputDirectory()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::getOutputDirectory(): string
```

#### `setOutputDirectory()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::setOutputDirectory(string $outputDirectory): void
```

#### `getMediaDirectory()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::getMediaDirectory(): string
```

#### `setMediaDirectory()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::setMediaDirectory(string $mediaDirectory): void
```

#### `getMediaOutputDirectory()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::getMediaOutputDirectory(): string
```

<!-- End generated docs for Hyde\Foundation\Concerns\ManagesHydeKernel -->

</section>


--- docs\_data\partials\hyde-pages-api\hyde-kernel-string-methods.md ---

<section id="hyde-kernel-string-methods">

<!-- Start generated docs for Hyde\Foundation\Concerns\ImplementsStringHelpers -->
<!-- Generated by HydePHP DocGen script at 2023-03-11 11:17:34 in 0.07ms -->

#### `makeTitle()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::makeTitle(string $value): string
```

#### `normalizeNewlines()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::normalizeNewlines(string $string): string
```

#### `stripNewlines()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::stripNewlines(string $string): string
```

#### `trimSlashes()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::trimSlashes(string $string): string
```

#### `markdown()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
Hyde::markdown(string $text, bool $normalizeIndentation): Illuminate\Support\HtmlString
```

<!-- End generated docs for Hyde\Foundation\Concerns\ImplementsStringHelpers -->

</section>


--- docs\_data\partials\hyde-pages-api\hyde-kernel-view-methods.md ---

<section id="hyde-kernel-view-methods">

<!-- Start generated docs for Hyde\Foundation\Concerns\ManagesViewData -->
<!-- Generated by HydePHP DocGen script at 2023-03-11 11:17:34 in 0.06ms -->

#### `shareViewData()`

Share data for the page being rendered.

```php
// torchlight! {"lineNumbers": false}
Hyde::shareViewData(Hyde\Pages\Concerns\HydePage $page): void
```

#### `currentRouteKey()`

Get the route key for the page being rendered.

```php
// torchlight! {"lineNumbers": false}
Hyde::currentRouteKey(): string
```

#### `currentRoute()`

Get the route for the page being rendered.

```php
// torchlight! {"lineNumbers": false}
Hyde::currentRoute(): Hyde\Support\Models\Route
```

#### `currentPage()`

Get the page being rendered.

```php
// torchlight! {"lineNumbers": false}
Hyde::currentPage(): Hyde\Pages\Concerns\HydePage
```

<!-- End generated docs for Hyde\Foundation\Concerns\ManagesViewData -->

</section>


--- docs\_data\partials\hyde-pages-api\hyde-page-methods.md ---

<section id="hyde-page-methods">

<!-- Start generated docs for Hyde\Pages\Concerns\HydePage -->
<!-- Generated by HydePHP DocGen script at 2023-03-10 16:18:02 in 3.30ms -->

#### `make()`

Create a new page instance. Static alias for the constructor.

```php
// torchlight! {"lineNumbers": false}
HydePage::make(string $identifier, Hyde\Markdown\Models\FrontMatter|array $matter): static
```

#### `isDiscoverable()`

Returns whether the page type is discoverable through auto-discovery.

```php
// torchlight! {"lineNumbers": false}
HydePage::isDiscoverable(): bool
```

#### `get()`

Get a page instance from the Kernel&#039;s page index by its identifier.

```php
// torchlight! {"lineNumbers": false}
HydePage::get(string $identifier): Hyde\Pages\Concerns\HydePage
```

- **Throws:** \Hyde\Framework\Exceptions\FileNotFoundException If the page does not exist.

#### `parse()`

Parse a source file into a new page model instance.

```php
// torchlight! {"lineNumbers": false}
/** @param string $identifier The identifier of the page to parse. */
HydePage::parse(string $identifier): static // New page model instance for the parsed source file.
```

- **Throws:** \Hyde\Framework\Exceptions\FileNotFoundException If the file does not exist.

#### `files()`

Get an array of all the source file identifiers for the model.

Note that the values do not include the source directory or file extension.

```php
// torchlight! {"lineNumbers": false}
HydePage::files(): array<string>
```

#### `all()`

Get a collection of all pages, parsed into page models.

```php
// torchlight! {"lineNumbers": false}
HydePage::all(): \Hyde\Foundation\Kernel\PageCollection<static>
```

#### `sourceDirectory()`

Get the directory where source files are stored for the page type.

```php
// torchlight! {"lineNumbers": false}
HydePage::sourceDirectory(): string
```

#### `outputDirectory()`

Get the output subdirectory to store compiled HTML files for the page type.

```php
// torchlight! {"lineNumbers": false}
HydePage::outputDirectory(): string
```

#### `fileExtension()`

Get the file extension of the source files for the page type.

```php
// torchlight! {"lineNumbers": false}
HydePage::fileExtension(): string
```

#### `setSourceDirectory()`

Set the output directory for the page type.

```php
// torchlight! {"lineNumbers": false}
HydePage::setSourceDirectory(string $sourceDirectory): void
```

#### `setOutputDirectory()`

Set the source directory for the page type.

```php
// torchlight! {"lineNumbers": false}
HydePage::setOutputDirectory(string $outputDirectory): void
```

#### `setFileExtension()`

Set the file extension for the page type.

```php
// torchlight! {"lineNumbers": false}
HydePage::setFileExtension(string $fileExtension): void
```

#### `sourcePath()`

Qualify a page identifier into file path to the source file, relative to the project root.

```php
// torchlight! {"lineNumbers": false}
HydePage::sourcePath(string $identifier): string
```

#### `outputPath()`

Qualify a page identifier into a target output file path, relative to the _site output directory.

```php
// torchlight! {"lineNumbers": false}
HydePage::outputPath(string $identifier): string
```

#### `path()`

Get an absolute file path to the page&#039;s source directory, or a file within it.

```php
// torchlight! {"lineNumbers": false}
HydePage::path(string $path): string
```

#### `pathToIdentifier()`

Format a filename to an identifier for a given model. Unlike the basename function, any nested paths within the source directory are retained in order to satisfy the page identifier definition.

```php
// torchlight! {"lineNumbers": false}
/** @param string $path Example: index.blade.php */
HydePage::pathToIdentifier(string $path): string // Example: index
```

#### `baseRouteKey()`

Get the route key base for the page model.

This is the same value as the output directory.

```php
// torchlight! {"lineNumbers": false}
HydePage::baseRouteKey(): string
```

#### `__construct()`

Construct a new page instance.

```php
// torchlight! {"lineNumbers": false}
$page = new HydePage(string $identifier, Hyde\Markdown\Models\FrontMatter|array $matter): void
```

#### `compile()`

Compile the page into static HTML.

```php
// torchlight! {"lineNumbers": false}
$page->compile(): string // The compiled HTML for the page.
```

#### `toArray()`

Get the instance as an array.

```php
// torchlight! {"lineNumbers": false}
$page->toArray(): array
```

#### `getSourcePath()`

Get the path to the instance source file, relative to the project root.

```php
// torchlight! {"lineNumbers": false}
$page->getSourcePath(): string
```

#### `getOutputPath()`

Get the path where the compiled page will be saved.

```php
// torchlight! {"lineNumbers": false}
$page->getOutputPath(): string // Path relative to the site output directory.
```

#### `getRouteKey()`

Get the route key for the page.

The route key is the page URL path, relative to the site root, but without any file extensions. For example, if the page will be saved to `_site/docs/index.html`, the key is `docs/index`.

Route keys are used to identify page routes, similar to how named routes work in Laravel, only that here the name is not just arbitrary, but also defines the output location, as the route key is used to determine the output path which is `$routeKey.html`.

```php
// torchlight! {"lineNumbers": false}
$page->getRouteKey(): string
```

#### `getRoute()`

Get the route object for the page.

```php
// torchlight! {"lineNumbers": false}
$page->getRoute(): Hyde\Support\Models\Route
```

#### `getLink()`

Format the page instance to a URL path, with support for pretty URLs if enabled.

Note that the link is always relative to site root, and does not contain `../` segments.

```php
// torchlight! {"lineNumbers": false}
$page->getLink(): string
```

#### `getIdentifier()`

Get the page model&#039;s identifier property.

The identifier is the part between the source directory and the file extension. It may also be known as a &#039;slug&#039;, or previously &#039;basename&#039;, but it retains the nested path structure if the page is stored in a subdirectory.

For example, the identifier of a source file stored as &#039;_pages/about/contact.md&#039; would be &#039;about/contact&#039;, and &#039;pages/about.md&#039; would simply be &#039;about&#039;.

```php
// torchlight! {"lineNumbers": false}
$page->getIdentifier(): string
```

#### `getBladeView()`

Get the Blade template/view key for the page.

```php
// torchlight! {"lineNumbers": false}
$page->getBladeView(): string
```

#### `title()`

Get the page title to display in HTML tags like `<title>` and `<meta>` tags.

```php
// torchlight! {"lineNumbers": false}
$page->title(): string
```

#### `metadata()`

Get the generated metadata for the page.

```php
// torchlight! {"lineNumbers": false}
$page->metadata(): Hyde\Framework\Features\Metadata\PageMetadataBag
```

#### `showInNavigation()`

Can the page be shown in the navigation menu?

```php
// torchlight! {"lineNumbers": false}
$page->showInNavigation(): bool
```

#### `navigationMenuPriority()`

Get the priority of the page in the navigation menu.

```php
// torchlight! {"lineNumbers": false}
$page->navigationMenuPriority(): int
```

#### `navigationMenuLabel()`

Get the label of the page in the navigation menu.

```php
// torchlight! {"lineNumbers": false}
$page->navigationMenuLabel(): string
```

#### `navigationMenuGroup()`

Get the group of the page in the navigation menu, if any.

```php
// torchlight! {"lineNumbers": false}
$page->navigationMenuGroup(): string
```

<!-- End generated docs for Hyde\Pages\Concerns\HydePage -->

</section>


--- docs\_data\partials\hyde-pages-api\in-memory-page-methods.md ---

<section id="in-memory-page-methods">

<!-- Start generated docs for Hyde\Pages\InMemoryPage -->
<!-- Generated by HydePHP DocGen script at 2023-03-10 20:57:31 in 0.46ms -->

#### `make()`

Static alias for the constructor.

```php
// torchlight! {"lineNumbers": false}
InMemoryPage::make(string $identifier, Hyde\Markdown\Models\FrontMatter|array $matter, string $contents, string $view): static
```

#### `__construct()`

Create a new in-memory/virtual page instance.

The in-memory page class offers two content options. You can either pass a string to the $contents parameter, Hyde will then save that literally as the page&#039;s contents. Alternatively, you can pass a view name to the $view parameter, and Hyde will use that view to render the page contents with the supplied front matter during the static site build process.

Note that $contents take precedence over $view, so if you pass both, only $contents will be used. You can also register a macro with the name &#039;compile&#039; to overload the default compile method.

If the identifier for an in-memory page is &quot;foo/bar&quot; the page will be saved to &quot;_site/foo/bar.html&quot;. You can then also use the route helper to get a link to it by using the route key &quot;foo/bar&quot;. Take note that the identifier must be unique to prevent overwriting other pages. all this data will be passed to the view rendering engine.
- **Parameter $view:** The view key or Blade file for the view to use to render the page contents.
- **Parameter $matter:** The front matter of the page. When using the Blade view rendering option,


```php
// torchlight! {"lineNumbers": false}
$page = new InMemoryPage(string $identifier, \Hyde\Markdown\Models\FrontMatter|array $matter, string $contents, string $view): void
```

#### `getContents()`

Get the contents of the page. This will be saved as-is to the output file when this strategy is used.

```php
// torchlight! {"lineNumbers": false}
$page->getContents(): string
```

#### `getBladeView()`

Get the view key or Blade file for the view to use to render the page contents when this strategy is used.

```php
// torchlight! {"lineNumbers": false}
$page->getBladeView(): string
```

#### `compile()`

Get the contents that will be saved to disk for this page.

In order to make your virtual page easy to use we provide a few options for how the page can be compiled. If you want even more control, you can register a macro with the name &#039;compile&#039; to overload the method, or simply extend the class and override the method yourself, either in a standard or anonymous class.

```php
// torchlight! {"lineNumbers": false}
$page->compile(): string
```

#### `macro()`

Register a macro for the instance.

Unlike most macros you might be used to, these are not static, meaning they belong to the instance. If you have the need for a macro to be used for multiple pages, you should create a custom page class instead.

```php
// torchlight! {"lineNumbers": false}
$page->macro(string $name, callable $macro): void
```

#### `hasMacro()`

Determine if a macro with the given name is registered for the instance.

```php
// torchlight! {"lineNumbers": false}
$page->hasMacro(string $method): bool
```

#### `__call()`

Dynamically handle macro calls to the class.

```php
// torchlight! {"lineNumbers": false}
$page->__call(string $method, array $parameters): mixed
```

<!-- End generated docs for Hyde\Pages\InMemoryPage -->

</section>


--- docs\_data\partials\hyde-pages-api\interacts-with-front-matter-methods.md ---

<section id="interacts-with-front-matter-methods">

<!-- Start generated docs for Hyde\Framework\Concerns\InteractsWithFrontMatter -->
<!-- Generated by HydePHP DocGen script at 2023-03-10 18:25:46 in 0.06ms -->

#### `data()`

Get a value from the computed page data, or fallback to the page&#039;s front matter, then to the default value.

```php
// torchlight! {"lineNumbers": false}
$page->data(string $key, mixed $default): \Hyde\Markdown\Models\FrontMatter|mixed
```

#### `matter()`

Get the front matter object, or a value from within.

```php
// torchlight! {"lineNumbers": false}
$page->matter(string $key, mixed $default): \Hyde\Markdown\Models\FrontMatter|mixed
```

#### `has()`

See if a value exists in the computed page data or the front matter.

```php
// torchlight! {"lineNumbers": false}
$page->has(string $key): bool
```

<!-- End generated docs for Hyde\Framework\Concerns\InteractsWithFrontMatter -->

</section>


--- docs\_data\partials\hyde-pages-api\markdown-page-methods.md ---

<section id="markdown-page-methods">

<!-- Start generated docs for Hyde\Pages\MarkdownPage -->
<!-- Generated by HydePHP DocGen script at 2023-03-10 20:54:06 in 1.07ms -->


<!-- End generated docs for Hyde\Pages\MarkdownPage -->

</section>


--- docs\_data\partials\hyde-pages-api\markdown-post-methods.md ---

<section id="markdown-post-methods">

<!-- Start generated docs for Hyde\Pages\MarkdownPost -->
<!-- Generated by HydePHP DocGen script at 2023-03-10 20:54:24 in 0.50ms -->

#### `getLatestPosts()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
MarkdownPost::getLatestPosts(): \Hyde\Foundation\Kernel\PageCollection<\Hyde\Pages\MarkdownPost>
```

#### `toArray()`

No description provided.

```php
// torchlight! {"lineNumbers": false}
$page->toArray(): array
```

<!-- End generated docs for Hyde\Pages\MarkdownPost -->

</section>


